//////////////////////////////////////////////////////
//
//   Harris Sheet Reconnection - Open Boundary Model
//
//////////////////////////////////////////////////////

//jgw//#include "injection"   //  Subroutine to compute re-injection velocity

//////////////////////////////////////////////////////

begin_globals {

  int restart_interval;
  int energies_interval;
  int fields_interval;
  int ehydro_interval;
  int Hhydro_interval;
  int eparticle_interval;
  int Hparticle_interval;
  int quota_check_interval;  // How frequently to check if quota exceeded

  int rtoggle;               // enables save of last 2 restart dumps for safety
  double quota_sec;          // Run quota in seconds
  double b0;                 // B0
  double bg;                 // Guide field
  //jgw//double v_A;
  double topology_x;       // domain topology
  double topology_y;
  double topology_z;

  // parameters for the collision model
  //jgw//int    ee_collisions; // Flag to signal we want to do e-e collisions.
  //jgw//int    ei_collisions; // Flag to signal we want to do e-i collisions.
  //jgw//int    ii_collisions; // Flag to signal we want to do i-i collisions.

  //jgw//double cvar; // Base variance (dimensionless) used in particle collision
  //jgw//double nppc_max; // Max number of particles/cell (used to define key array size).
  //jgw//int tstep_coll;  // Collision interval (=multiple of sort interval).
  //jgw//double Z;
  //jgw//double mi_me;
  //jgw//double wpewce;

  //  Variables for Open BC Model
  //jgw//double nb;      // Background density
  //jgw//int nsp;        //  Number of Species
  //jgw//double vth[2];  // Thermal velocity of Harris components
  //jgw//double vthb[2]; // Thermal velocity of background components
  //jgw//double q[2];    // Species charge
  //jgw//double L_de;    //  Initial Harris sheet thickness
  //jgw//double uf[2];   // Initial Fluid Drift in Harris
  //jgw//double nfac;    //  Normalization factor to convert particles per cell into density
  //jgw//double rin[3];  //  Relaxation parameter for inflow boundary moments
  //jgw//double rout[3]; //  Relaxation parameter for outlfow boundary moments
  //jgw//double sort[2]; // Intervals where we know particles are sorted
  //jgw//double edrive;  // Drive field for inflow boundary
  //jgw//double tdrive;
  //jgw//int left,right,top,bottom;  // Keep track of boundary domains
  //jgw//double *nbot, *ubot, *pbot, *bbot, *fbot;         // Moments for bottom injectors
  //jgw//double *ntop, *utop, *ptop, *btop, *ftop;         // Moments for top injectors
  //jgw//double *nleft, *uleft, *pleft, *bleft, *fleft;     // Moments for left injectors
  //jgw//double *nright, *uright, *pright, *bright, *fright; // Moments for right injectors

  // Output variables
  DumpParameters fdParams;
  DumpParameters hedParams;
  DumpParameters hHdParams;
  std::vector<DumpParameters *> outputParams;
};

begin_initialization {

  // use natural PIC units
  double ec   = 1;         // Charge normalization
  double me   = 1;         // Mass normalization
  double c    = 1;         // Speed of light
  double de   = 1;         // Length normalization (electron inertial length)
  double eps0 = 1;         // Permittivity of space

  double cfl_req   = 0.99;  // How close to Courant should we try to run
  double wpedt_max = 0.36;  // Max dt allowed if Courant not too restrictive
  //jgw//double damp      = 0.0;   // Level of radiation damping
  int rng_seed     = 1;     // Random number seed increment

  // Physics parameters
  double mi_me   = 400.0;  // Ion mass / electron mass
  double L_di    = 0.5;    // Sheet thickness / ion inertial length
  double Ti_Te   = 5.0;    // Ion temperature / electron temperature
  //jgw//double Z   = 1.0;      // Ion charge
  //jgw//double nb_n0   = 0.228;   // background plasma density
  //jgw//double Tbe_Te  = 0.7598;  // Ratio of background electron temperature to Harris electron temperature
  //jgw//double Tbi_Ti  = 0.3039;  // Ratio of background ion temperature to Harris ion temperature
  //jgw//double wpe_wce = 2.0;      // electron plasma freq / electron cyclotron freq
  //jgw//double bg = 0.0;        // electron plasma freq / electron cyclotron freq
  //jgw//double theta   = 0;      // B0 = Bx
  //jgw//double taui    = 300;    // simulation wci's to run
  //jgw//
  //jgw//double quota   = 11.0;   // run quota in hours
  //jgw//double quota_sec = quota*3600;  // Run quota in seconds
//jgw//
  //jgw//double cs   = cos(theta);
  //jgw//double sn   = sin(theta);
//jgw//
  //jgw////derived qunatities
  //jgw//double mi = me*mi_me;                                   // Ion mass
  //jgw//double Te = me*c*c/(2*eps0*wpe_wce*wpe_wce*(1+Ti_Te));  // Electron temperature
  //jgw//double Ti = Te*Ti_Te;                                   // Ion temperature
  //jgw//double vthe = sqrt(Te/me);                              // Electron thermal velocity
  //jgw//double vthi = sqrt(Ti/mi);                              // Ion thermal velocity
  //jgw//double vtheb = sqrt(Tbe_Te*Te/me);             // normalized background electron thermal velocity
  //jgw//double vthib = sqrt(Tbi_Ti*Ti/mi);             // normalized background ion thermal velocity
  //jgw//double wci  = 1.0/(mi_me*wpe_wce);                      // Ion cyclotron frequency
  //jgw//double wce  = wci*mi_me;                                // Electron cyclotron freqeuncy
  //jgw//double wpe  = wce*wpe_wce;                              // electron plasma frequency
  //jgw//double wpi  = wpe/sqrt(mi_me);                          // ion plasma frequency
  //jgw//double di   = c/wpi;                                    // ion inertial length
  //jgw//double L    = L_di*di;                                  // Harris sheet thickness
  //jgw//double rhoi_L = sqrt(Ti_Te/(1.0+Ti_Te))/L_di;
  //jgw//double v_A= (wci/wpi)/sqrt(nb_n0); //  based on nb
//jgw//
  //jgw////  Parameters for Open BC model
//jgw//
  //jgw//double rin[3] =  {0.000, 0.06, 0.000};  //  Relaxation - density, velocity + particle flux, pressure tensor
  //jgw//double rout[3] = {0.002, 0.002, 0.002};  //  Relaxation - density, velocity + particle flux, pressure tensor
  //jgw//double edrive = 0.08*v_A/(wpe_wce);    //  Setting edrive = 0 will give undriven limit
  //jgw////  double edrive = 0.0099;    //  Setting edrive = 0 will give undriven limit
  //jgw//
  //jgw//double tdrive = 32000.0;
  //jgw//double sort_interval = 10;        //  Injector moments are also updated at this internal
  //jgw//
  //jgw//// Numerical parameters
//jgw//
  //jgw//double nppc          = 400; // Average number of macro particle per cell per species
//jgw//
  //jgw//double Lx            = 20*di; // size of box in x dimension
  //jgw//double Ly            = 0.00781*di;  // size of box in y dimension
  //jgw//double Lz            = 20*di; // size of box in z dimension
//jgw//
  //jgw//int topology_factor = 4;
//jgw//
  //jgw//double topology_x = 256/topology_factor;  // Number of domains in x, y, and z
  //jgw//double topology_y = 1;
  //jgw//double topology_z = 1;  // For load balance, best to keep "1" or "2" for Harris sheet
//jgw//
  //jgw//double nx = 2560/sqrt(topology_factor);
  //jgw//double ny = 1;
  //jgw//double nz = 2560/sqrt(topology_factor);
//jgw//
  //jgw//double hx = Lx/nx;
  //jgw//double hy = Ly/ny;
  //jgw//double hz = Lz/nz;
//jgw//
  //jgw//double b0            = me*c*wce/ec; // Asymptotic magnetic field strength
  //jgw//double n0            = me*eps0*wpe*wpe/(ec*ec);  // Peak electron (ion) density
  //jgw//double vdri          = 2*c*Ti/(ec*b0*L);   // Ion drift velocity
  //jgw//double vdre          = -vdri/(Ti_Te);           // electron drift velocity
//jgw//
  //jgw//double Npe_sheet     = 2*n0*Lx*Ly*L*tanh(0.5*Lz/L); // number of physical electrons in sheet
  //jgw//double Npe_back      = nb_n0*n0*Ly*Lz*Lx;    // Number of physical electrons in background
  //jgw//double Npe           = Npe_sheet + Npe_back;
  //jgw//double Ne            = nppc*nx*ny*nz;  // total macro electrons in box
  //jgw//double Ne_sheet      = Ne*Npe_sheet/Npe;
  //jgw//double Ne_back       = Ne*Npe_back/Npe;
  //jgw//Ne_sheet  = trunc_granular(Ne_sheet,nproc()); // Make it divisible by number of processors
  //jgw//Ne_back  = trunc_granular(Ne_back,nproc()); // Make it divisible by number of processors
  //jgw//Ne = Ne_sheet + Ne_back;
  //jgw//double qe_s = -ec*Npe_sheet/Ne_sheet;  // Charge per macro electron
  //jgw//double qe_b = -ec*Npe_back/Ne_back;  // Charge per macro electron
  //jgw//double qi_s =  ec*Npe_sheet/Ne_sheet;  // Charge per macro electron
  //jgw//double qi_b =  ec*Npe_back/Ne_back;  // Charge per macro electron
  //jgw//double nfac = qi_s/(hx*hy*hz);            // Convert density to particles per cell
  //jgw//
  //jgw//double gdri = 1/sqrt(1-vdri*vdri/(c*c));  // gamma of ion drift frame
  //jgw//double gdre = 1/sqrt(1-vdre*vdre/(c*c)); // gamma of electron drift frame
  //jgw//double udri = vdri*gdri;                 // 4-velocity of ion drift frame
  //jgw//double udre = vdre*gdre;                  // 4-velocity of electron drift frame
  //jgw//double tanhf = tanh(0.5*Lz/L);
  //jgw//double Lpert = 1.5*Lx;   // wavelength of perturbation
  //jgw//double dbz =  0.03*b0; //  Perturbation in Bz relative to Bo (Only change here)
  //jgw//double dbx = -dbz*Lpert/(2*Lz); // Set Bx perturbation so that div(B) = 0
//jgw//
  //jgw//// Determine the time step
//jgw//
  //jgw//double dg = courant_length(Lx,Ly,Lz,nx,ny,nz);        // courant length
  //jgw//double dt = cfl_req*dg/c;                             // courant limited time step
  //jgw//if( wpe*dt>wpedt_max) dt=wpedt_max/wpe;               // override timestep if plasma frequency limited
  //jgw//
  //jgw//// Intervals for output
//jgw//
  //jgw//int restart_interval = 8000;
  //jgw//int energies_interval = 1000;
  //jgw//int interval = int(0.25/(wci*dt));
  //jgw//int fields_interval = interval;
  //jgw//int ehydro_interval = interval;
  //jgw//int Hhydro_interval = interval;
  //jgw//int eparticle_interval = 8*interval;
  //jgw//int Hparticle_interval = 8*interval;
  //jgw//int quota_check_interval     = 100;
//jgw//
  //jgw//// Collision parameters
  //jgw//// In CGS, variance of tan theta = 2 pi e^4 n_e dt_coll loglambda / (m_ab^2 u^3)
//jgw//
  //jgw//int ii_collisions = 1;                   // flags to do collisions between the corresponding species
  //jgw//int ee_collisions = 1;                   //
  //jgw//int ei_collisions = 1;                   //
//jgw//
  //jgw//int tstep_coll = (int) sort_interval;          // How frequently to apply collision operator
  //jgw//double dt_coll = dt*(tstep_coll);          // in (1/wpe)
  //jgw//double nuei_wce = 0.05;
  //jgw//double cvar = dt_coll*3.0*sqrt(2.0*M_PI)/4.0*pow(vthe,3)*nuei_wce/wpe_wce;
  //jgw//double nppc_max   = 20*nppc;             // Max possible number of particles/cell of ea. species
  //jgw//                                         // (to size the key array in collision handler)
//jgw//
  //jgw////  Determine which domains area along the boundaries - Use macro from grid/partition.c
//jgw//
//jgw//# define RANK_TO_INDEX(rank,ix,iy,iz) BEGIN_PRIMITIVE {                   \
  //jgw//  int _ix, _iy, _iz;                                                    \
  //jgw//  _ix  = (rank);                        /* ix = ix+gpx*( iy+gpy*iz ) */ \
  //jgw//  _iy  = _ix/int(topology_x);   /* iy = iy+gpy*iz */                    \
  //jgw//  _ix -= _iy*int(topology_x);   /* ix = ix */                           \
  //jgw//  _iz  = _iy/int(topology_y);   /* iz = iz */                           \
  //jgw//  _iy -= _iz*int(topology_y);   /* iy = iy */ 	        	  \
  //jgw//  (ix) = _ix;                                                           \
  //jgw//  (iy) = _iy;                                                           \
  //jgw//  (iz) = _iz;                                                           \
  //jgw//} END_PRIMITIVE
//jgw//
  //jgw//int ix, iy, iz, left=0,right=0,top=0,bottom=0;
  //jgw//RANK_TO_INDEX( int(rank()), ix, iy, iz );
  //jgw//if ( ix ==0 ) left=1;
  //jgw//if ( ix ==topology_x-1 ) right=1;
  //jgw//if ( iz ==0 ) bottom=1;
  //jgw//if ( iz ==topology_z-1 ) top=1;
//jgw//
  //jgw/////////////////////////////////////////////////
  //jgw//// Setup high level simulation parameters
  //jgw//num_step             = int(taui/(wci*dt));
  //jgw//num_step             = 200;
  //jgw//status_interval      = 200;
  //jgw//sync_shared_interval = status_interval/2;
  //jgw//clean_div_e_interval = status_interval/2;
  //jgw//clean_div_b_interval = status_interval/2;
//jgw//
  //jgw//global->restart_interval   = restart_interval;
  //jgw//global->energies_interval  = energies_interval;
  //jgw//global->fields_interval    = fields_interval;
  //jgw//global->ehydro_interval    = ehydro_interval;
  //jgw//global->Hhydro_interval    = Hhydro_interval;
  //jgw//global->eparticle_interval = eparticle_interval;
  //jgw//global->Hparticle_interval = Hparticle_interval;
  //jgw//global->quota_check_interval     = quota_check_interval;
  //jgw//global->quota_sec          = quota_sec;
//jgw//
  //jgw//global->rtoggle            = 0;
  //jgw//global->b0  = b0;
  //jgw//global->bg  = bg;
  //jgw//global->v_A  = v_A;
  //jgw//global->edrive  = edrive;
  //jgw//global->tdrive  = tdrive;
//jgw//
  //jgw//global->topology_x  = topology_x;
  //jgw//global->topology_y  = topology_y;
  //jgw//global->topology_z  = topology_z;
//jgw//
  //jgw//global->left = left;
  //jgw//global->right = right;
  //jgw//global->top = top;
  //jgw//global->bottom = bottom;
//jgw//
  //jgw////  Parameters for the open boundary model
//jgw//
  //jgw//global->nsp = 2;
  //jgw//global->nb  = nb_n0;
  //jgw//global->rin[0]  = rin[0];
  //jgw//global->rin[1]  = rin[1];
  //jgw//global->rin[2]  = rin[2];
  //jgw//global->rout[0]  = rout[0];
  //jgw//global->rout[1]  = rout[1];
  //jgw//global->rout[2]  = rout[2];
  //jgw//global->vth[0]  = sqrt(2)*vthe;
  //jgw//global->vth[1]  = sqrt(2)*vthi;
  //jgw//global->vthb[0]  = sqrt(2)*vtheb;
  //jgw//global->vthb[1]  = sqrt(2)*vthib;
  //jgw//global->q[0]  = qe_s;
  //jgw//global->q[1]  = qi_s;
  //jgw//global->uf[0]  = udre;
  //jgw//global->uf[1]  = udri;
  //jgw//global->sort[0]  = sort_interval;
  //jgw//global->sort[1]  = sort_interval;
  //jgw//global->nfac  = nfac;
  //jgw//global->L_de  = L;
//jgw//
  //jgw//// Collision model parameters
//jgw//
  //jgw//global->ee_collisions            = ee_collisions;
  //jgw//global->ii_collisions            = ii_collisions;
  //jgw//global->ei_collisions            = ei_collisions;
//jgw//
  //jgw//global->cvar                     = cvar;
  //jgw//global->nppc_max                 = nppc_max;
  //jgw//global->tstep_coll               = tstep_coll;
  //jgw//global->mi_me                    = mi_me;
  //jgw//global->Z                        = Z;
  //jgw//global->wpewce                   = wpe_wce;
  //jgw//global->nfac                     = nfac;
//jgw//
  //jgw//////////////////////////////////////////////////////////////////////////////////////////////
  //jgw//// Setup the grid
//jgw//
  //jgw//// Setup basic grid parameters
  //jgw//grid->dx = hx;
  //jgw//grid->dy = hy;
  //jgw//grid->dz = hz;
  //jgw//grid->dt = dt;
  //jgw//grid->cvac = c;
  //jgw//grid->eps0 = eps0;
  //jgw//grid->damp = damp;
//jgw//
  //jgw//// Define the grid
  //jgw//
  //jgw//define_periodic_grid(  0, -0.5*Ly, -0.5*Lz,    // Low corner
//jgw//			  Lx, 0.5*Ly, 0.5*Lz,     // High corner
//jgw//			  nx, ny, nz,             // Resolution
//jgw//			  topology_x, topology_y, topology_z); // Topology
//jgw//
//jgw// // ***** Set Field Boundary Conditions *****
//jgw//
  //jgw////  sim_log("Absorbing fields on X & Z-boundaries");
  //jgw////if ( iz==0 )            set_domain_field_bc( BOUNDARY(0,0,-1), absorb_fields );
  //jgw////if ( iz==topology_z-1 ) set_domain_field_bc( BOUNDARY( 0,0,1), absorb_fields );
  //jgw//if ( ix==0 )            set_domain_field_bc( BOUNDARY(-1,0,0), absorb_fields );
  //jgw//if ( ix==topology_x-1 ) set_domain_field_bc( BOUNDARY( 1,0,0), absorb_fields );
  //jgw//
  //jgw//sim_log("Conducting fields on X & Z-boundaries");
  //jgw//if ( iz==0 )            set_domain_field_bc( BOUNDARY(0,0,-1), pec_fields );
  //jgw//if ( iz==topology_z-1 ) set_domain_field_bc( BOUNDARY( 0,0,1), pec_fields );
  //jgw////if ( ix==0 )            set_domain_field_bc( BOUNDARY(-1,0,0), pec_fields );
  //jgw////if ( ix==topology_x-1 ) set_domain_field_bc( BOUNDARY( 1,0,0), pec_fields );
//jgw//
//jgw// // ***** Set Particle Boundary Conditions *****
//jgw//
  //jgw//sim_log("Absorb particles on X & Z-boundaries");
  //jgw//if ( iz==0 )            set_domain_particle_bc( BOUNDARY(0,0,-1), absorb_particles );
  //jgw//if ( iz==topology_z-1 ) set_domain_particle_bc( BOUNDARY(0,0,1), absorb_particles );
  //jgw//if ( ix==0 )            set_domain_particle_bc( BOUNDARY(-1,0,0), absorb_particles );
  //jgw//if ( ix==topology_x-1 ) set_domain_particle_bc( BOUNDARY(1,0,0), absorb_particles );
//jgw//
  //jgw//////////////////////////////////////////////////////////////////////////////////////////////
  //jgw//// Setup the species
//jgw//
  //jgw//sim_log("Setting up species. ");
  //jgw//species_t *electron = define_species("electron",-ec/me,2.5*Ne/nproc(),-1,sort_interval,0);
  //jgw//species_t *ion = define_species("ion", ec/mi,2.5*Ne/nproc(),-1,sort_interval,0);
//jgw//
  //jgw//////////////////////////////////////////////////////////////////////////////////////////////
  //jgw//// Setup materials
//jgw//
  //jgw//sim_log("Setting up materials. ");
//jgw//
  //jgw//define_material( "vacuum", 1 );
  //jgw//define_material( "resistive",1,1,1);
//jgw//
  //jgw//// Note: define_material defaults to isotropic materials with mu=1,sigma=0
  //jgw//// Tensor electronic, magnetic and conductive materials are supported
  //jgw//// though. See "shapes" for how to define them and assign them to regions.
  //jgw//// Also, space is initially filled with the first material defined.
//jgw//
//jgw//////////////////////////////////////////////////////////////////////////////////////////////
//jgw////  Finalize Field Advance
//jgw//
  //jgw//sim_log("Finalizing Field Advance");
//jgw//
  //jgw//finalize_field_advance(standard_field_advance);
//jgw//
  //jgw////  Define resistive layer surrounding boundary --> set thickness=0 to eliminate this feature
//jgw//
  //jgw//  double thickness = 2;
//jgw//#define resistive_layer (x < hx*thickness || x > Lx-hx*thickness || z <-Lz/2+hz*thickness  || z > Lz/2-hz*thickness )
//jgw//
  //jgw//  if (thickness > 0) set_region_material(resistive_layer, "resistive", "resistive")    ;
//jgw//
  //jgw/////////////////////////////////////////////////////
  //jgw//// Log diagnostic information about this simulation
//jgw//
  //jgw//sim_log( "***********************************************" );
  //jgw//sim_log("* Topology:                       "<<topology_x<<" "<<topology_y<<" "<<topology_z);
  //jgw//sim_log ( "tanhf = " << tanhf );
  //jgw//sim_log ( "L_di   = " << L_di );
  //jgw//sim_log ( "rhoi/L   = " << rhoi_L );
  //jgw//sim_log ( "Ti/Te = " << Ti_Te ) ;
  //jgw//sim_log ( "nb/n0 = " << nb_n0 ) ;
  //jgw//sim_log ( "wpe/wce = " << wpe_wce );
  //jgw//sim_log ( "mi/me = " << mi_me );
  //jgw//sim_log ( "theta = " << theta );
  //jgw//sim_log ( "taui = " << taui );
  //jgw//sim_log ( "num_step = " << num_step );
  //jgw//sim_log ( "Lx/di = " << Lx/di );
  //jgw//sim_log ( "Lx/de = " << Lx/de );
  //jgw//sim_log ( "Ly/di = " << Ly/di );
  //jgw//sim_log ( "Ly/de = " << Ly/de );
  //jgw//sim_log ( "Lz/di = " << Lz/di );
  //jgw//sim_log ( "Lz/de = " << Lz/de );
  //jgw//sim_log ( "nx = " << nx );
  //jgw//sim_log ( "ny = " << ny );
  //jgw//sim_log ( "nz = " << nz );
  //jgw//sim_log ( "damp = " << damp );
  //jgw//sim_log ( "courant = " << c*dt/dg );
  //jgw//sim_log ( "nproc = " << nproc ()  );
  //jgw//sim_log ( "nppc = " << nppc );
  //jgw//sim_log ( " b0 = " << b0 );
  //jgw//sim_log ( " v_A (based on nb) = " << v_A );
  //jgw//sim_log ( " di = " << di );
  //jgw//sim_log ( " Ne = " << Ne );
  //jgw//sim_log ( " Ne_sheet = " << Ne_sheet );
  //jgw//sim_log ( " Ne_back = " << Ne_back );
  //jgw//sim_log ( "total # of particles = " << 2*Ne );
  //jgw//sim_log ( "dt*wpe = " << wpe*dt );
  //jgw//sim_log ( "dt*wce = " << wce*dt );
  //jgw//sim_log ( "dt*wci = " << wci*dt );
  //jgw//sim_log ( " energies_interval: " << energies_interval );
  //jgw//sim_log ( "dx/de = " << Lx/(de*nx) );
  //jgw//sim_log ( "dy/de = " << Ly/(de*ny) );
  //jgw//sim_log ( "dz/de = " << Lz/(de*nz) );
  //jgw//sim_log ( "dx/rhoi = " << (Lx/nx)/(vthi/wci)  );
  //jgw//sim_log ( "dx/rhoe = " << (Lx/nx)/(vthe/wce)  );
  //jgw//sim_log ( "L/debye = " << L/(vthe/wpe)  );
  //jgw//sim_log ( "dx/debye = " << (Lx/nx)/(vthe/wpe)  );
  //jgw//sim_log ( "n0 = " << n0 );
  //jgw//sim_log ( "vthi/c = " << vthi/c );
  //jgw//sim_log ( "vthe/c = " << vthe/c );
  //jgw//sim_log ( "vdri/c = " << vdri/c );
  //jgw//sim_log ( "vdre/c = " << vdre/c );
  //jgw//sim_log("* nu/wce:                        "<<nuei_wce);
  //jgw//sim_log("* nu*dt_coll:                    "<<nuei_wce/wpe_wce*dt_coll);
  //jgw//
  //jgw//// Dump simulation information to file "info"
  //jgw//if (rank() == 0 ) {
  //jgw//  FILE *fp_info;
  //jgw//  if ( ! (fp_info=fopen("info", "w")) ) ERROR(("Cannot open file."));
  //jgw//  fprintf(fp_info, "           ***** Simulation parameters ***** \n");
  //jgw//  fprintf(fp_info, "		 L/di	=		%e\n", L_di);
  //jgw//  fprintf(fp_info, "		 L/de	=		%e\n", L/de);
  //jgw//  fprintf(fp_info, "		 rhoi/L	=		%e\n", rhoi_L);
  //jgw//  fprintf(fp_info, "		 Ti/Te	=		%e\n", Ti_Te );
  //jgw//  fprintf(fp_info, "		 Tbi/Ti	=		%e\n", Tbi_Ti );
  //jgw//  fprintf(fp_info, "		 Tbe/Te	=		%e\n", Tbe_Te );
  //jgw//  fprintf(fp_info, "		 nb/n0 =		%e\n", nb_n0 );
  //jgw//  fprintf(fp_info, "		 wpe/wce = 		%e\n", wpe_wce );
  //jgw//  fprintf(fp_info, "		 mi/me =		%e\n", mi_me );
  //jgw//  fprintf(fp_info, "		 theta =		%e\n", theta );
  //jgw//  fprintf(fp_info, "		 taui =			%e\n", taui );
  //jgw//  fprintf(fp_info, "		 num_step = 		%i\n", num_step );
  //jgw//  fprintf(fp_info, "		 Lx/de = 		%e\n", Lx/de );
  //jgw//  fprintf(fp_info, "		 Ly/de = 		%e\n", Ly/de );
  //jgw//  fprintf(fp_info, "		 Lz/de =		%e\n", Lz/de );
  //jgw//  fprintf(fp_info, "		 Lx/di = 		%e\n", Lx/di );
  //jgw//  fprintf(fp_info, "		 Ly/di = 		%e\n", Ly/di );
  //jgw//  fprintf(fp_info, "		 Lz/di =		%e\n", Lz/di );
  //jgw//  fprintf(fp_info, "		 nx = 			%e\n", nx );
  //jgw//  fprintf(fp_info, "		 ny = 			%e\n", ny );
  //jgw//  fprintf(fp_info, "		 nz =			%e\n", nz );
  //jgw//  fprintf(fp_info, "		 damp =			%e\n", damp );
  //jgw//  fprintf(fp_info, "		 courant = 		%e\n", c*dt/dg );
  //jgw//  fprintf(fp_info, "		 nproc = 		%e\n", nproc() );
  //jgw//  fprintf(fp_info, "		 nppc = 		%e\n", nppc );
  //jgw//  fprintf(fp_info, "		 b0 =			%e\n", b0 );
  //jgw//  fprintf(fp_info, "		 v_A (based on nb) =	%e\n", v_A );
  //jgw//  fprintf(fp_info, "		 di = 			%e\n", di );
  //jgw//  fprintf(fp_info, "		 Ne = 			%e\n", Ne );
  //jgw//  fprintf(fp_info, "		 Ne_sheet = 		%e\n", Ne_sheet );
  //jgw//  fprintf(fp_info, "		 Ne_back = 		%e\n", Ne_back );
  //jgw//  fprintf(fp_info, "		 total # of particles = %e\n", 2*Ne );
  //jgw//  fprintf(fp_info, "		 dt*wpe = 		%e\n", wpe*dt );
  //jgw//  fprintf(fp_info, "		 dt*wce = 		%e\n", wce*dt );
  //jgw//  fprintf(fp_info, "		 dt*wci = 		%e\n", wci*dt );
  //jgw//  fprintf(fp_info, "		 energies_interval: 	%i\n", energies_interval);
  //jgw//  fprintf(fp_info, "		 dx/de =		%e\n", Lx/(de*nx) );
  //jgw//  fprintf(fp_info, "		 dy/de =		%e\n", Ly/(de*ny) );
  //jgw//  fprintf(fp_info, "		 dz/de =		%e\n", Lz/(de*nz) );
  //jgw//  fprintf(fp_info, "		 L/debye =		%e\n", L/(vthe/wpe) );
  //jgw//  fprintf(fp_info, "		 dx/rhoi =		%e\n", (Lx/nx)/(vthi/wci) );
  //jgw//  fprintf(fp_info, "		 dx/rhoe = 		%e\n", (Lx/nx)/(vthe/wce) );
  //jgw//  fprintf(fp_info, "		 dx/debye = 		%e\n", (Lx/nx)/(vthe/wpe) );
  //jgw//  fprintf(fp_info, "		 n0 =            	%e\n", n0 );
  //jgw//  fprintf(fp_info, "		 vthi/c =		%e\n", vthi/c );
  //jgw//  fprintf(fp_info, "		 vthe/c =		%e\n", vthe/c );
  //jgw//  fprintf(fp_info, "		 vdri/c =		%e\n", vdri/c );
  //jgw//  fprintf(fp_info, "		 vdre/c =		%e\n", vdre/c );
  //jgw//  fprintf(fp_info, " tstep_coll:                    %i\n", tstep_coll);
  //jgw//  fprintf(fp_info, " nu/wce:                        %g\n", nuei_wce);
  //jgw//  fprintf(fp_info, " nu*dt_coll:                    %g\n", nuei_wce/wpe_wce*dt_coll);
  //jgw//  fprintf(fp_info, "		 ***************************\n");
  //jgw//  fclose(fp_info);
//jgw//}
  //jgw//
//jgw//
  //jgw//////////////////////////////
  //jgw//// Load fields
//jgw//
  //jgw//sim_log( "Loading fields" );
  //jgw//set_region_field( everywhere, 0, 0, 0,                    // Electric field
//jgw//		    cs*b0*tanh(z/L)+dbx*cos(2.0*M_PI*(x-0.5*Lx)/Lpert)*sin(M_PI*z/Lz), //Bx
//jgw//		    -sn*b0*tanh(z/L) + b0*bg, //By
//jgw//		    dbz*cos(M_PI*z/Lz)*sin(2.0*M_PI*(x-0.5*Lx)/Lpert) ); // Bz
//jgw//
//jgw////  Localized Perturbation to lauch a light wave
//jgw//
//jgw////   # define R2 ((x-0.5*Lx)*(x-0.5*Lx) + z*z)/(L*L)
//jgw////     # define PERT  0.2*tanh(R2)/cosh(R2)
//jgw////     set_region_field( everywhere, 0, 0, 0,                    // Electric field
//jgw////     		    cs*b0*tanh(z/L) - z*PERT, //Bx
//jgw////     		    b0*bg, //By
//jgw////     		    (x-0.5*Lx)*PERT ); // Bz
//jgw//
  //jgw//// Note: everywhere is a region that encompasses the entire simulation
  //jgw//// In general, regions are specied as logical equations (i.e. x>0 && x+y<2)
//jgw//
  //jgw//// LOAD PARTICLES
//jgw//
  //jgw//sim_log( "Loading particles" );
//jgw//
  //jgw//// Do a fast load of the particles
//jgw//
  //jgw//seed_rand( rng_seed*nproc() + rank() );  //Generators desynchronized
  //jgw//double xmin = grid->x0 , xmax = grid->x0+(grid->dx)*(grid->nx);
  //jgw//double ymin = grid->y0 , ymax = grid->y0+(grid->dy)*(grid->ny);
  //jgw//double zmin = grid->z0 , zmax = grid->z0+(grid->dz)*(grid->nz);
  //jgw//
  //jgw//// Load Harris population
//jgw//
  //jgw//sim_log( "-> Main Harris Sheet" );
//jgw//
  //jgw//repeat ( Ne_sheet/nproc() ) {
  //jgw//  double x, y, z, ux, uy, uz, d0 ;
//jgw//
  //jgw//do {
  //jgw//  z = L*atanh(uniform_rand(-1,1)*tanhf);
  //jgw// } while( z<= zmin || z>=zmax );
  //jgw// x = uniform_rand(xmin,xmax);
  //jgw// y = uniform_rand(ymin,ymax);
//jgw//
  //jgw// // inject_particles() will return an error for particles no on this
  //jgw// // node and will not inject particle locally
//jgw//
  //jgw//  ux = maxwellian_rand(vthe);
  //jgw//  uy = maxwellian_rand(vthe);
  //jgw//  uz = maxwellian_rand(vthe);
  //jgw//  d0 = gdre*uy + sqrt(ux*ux + uy*uy + uz*uz + 1)*udre;
  //jgw//  uy = d0*cs - ux*sn;
  //jgw//  ux = d0*sn + ux*cs;
//jgw//
  //jgw//  inject_particle(electron, x, y, z, ux, uy, uz, qe_s, 0, 0 );
//jgw//
  //jgw//  ux = maxwellian_rand(vthi);
  //jgw//  uy = maxwellian_rand(vthi);
  //jgw//  uz = maxwellian_rand(vthi);
  //jgw//  d0 = gdri*uy + sqrt(ux*ux + uy*uy + uz*uz + 1)*udri;
  //jgw//  uy = d0*cs - ux*sn;
  //jgw//  ux = d0*sn + ux*cs;
//jgw//
  //jgw//  inject_particle(ion, x, y, z, ux, uy, uz, qi_s, 0, 0 );
  //jgw//
  //jgw//}
//jgw//
  //jgw//sim_log( "-> Background Population" );
//jgw//
  //jgw//repeat ( Ne_back/nproc() ) {
//jgw//
  //jgw//double z = uniform_rand(zmin,zmax);
  //jgw//double x = uniform_rand(xmin,xmax);
  //jgw//double y = uniform_rand(ymin,ymax);
//jgw//
  //jgw//inject_particle( electron, x, y, z,
//jgw//		   maxwellian_rand(vtheb),
//jgw//		   maxwellian_rand(vtheb),
//jgw//		   maxwellian_rand(vtheb),qe_b, 0, 0);
  //jgw//
  //jgw//inject_particle( ion, x, y, z,
//jgw//		   maxwellian_rand(vthib),
//jgw//		   maxwellian_rand(vthib),
//jgw//		   maxwellian_rand(vthib),qi_b, 0 ,0 );
  //jgw//}
//jgw//
  //jgw//sim_log( "Finished loading particles" );
//jgw//
  //jgw// /*--------------------------------------------------------------------------
  //jgw//   * New dump definition
  //jgw//   *------------------------------------------------------------------------*/
//jgw//
  //jgw//  /*--------------------------------------------------------------------------
//jgw//	 * Set data output format
//jgw//	 *
//jgw//	 * This option allows the user to specify the data format for an output
//jgw//	 * dump.  Legal settings are 'band' and 'band_interleave'.  Band-interleave
//jgw//	 * format is the native storage format for data in VPIC.  For field data,
//jgw//	 * this looks something like:
//jgw//	 *
//jgw//	 *   ex0 ey0 ez0 div_e_err0 cbx0 ... ex1 ey1 ez1 div_e_err1 cbx1 ...
//jgw//	 *
//jgw//	 * Banded data format stores all data of a particular state variable as a
//jgw//	 * contiguous array, and is easier for ParaView to process efficiently.
//jgw//	 * Banded data looks like:
//jgw//	 *
//jgw//	 *   ex0 ex1 ex2 ... exN ey0 ey1 ey2 ...
//jgw//	 *
  //jgw//   *------------------------------------------------------------------------*/
//jgw//
//jgw//	global->fdParams.format = band;
//jgw//
//jgw//	sim_log ( "Fields output format = band" );
//jgw//
//jgw//	global->hedParams.format = band;
//jgw//
//jgw//	sim_log ( "Electron species output format = band" );
//jgw//
//jgw//	global->hHdParams.format = band;
//jgw//
//jgw//	sim_log ( "Ion species output format = band" );
//jgw//
  //jgw//  /*--------------------------------------------------------------------------
//jgw//	 * Set stride
//jgw//	 *
//jgw//	 * This option allows data down-sampling at output.  Data are down-sampled
//jgw//	 * in each dimension by the stride specified for that dimension.  For
//jgw//	 * example, to down-sample the x-dimension of the field data by a factor
//jgw//	 * of 2, i.e., half as many data will be output, select:
//jgw//	 *
//jgw//	 *   global->fdParams.stride_x = 2;
//jgw//	 *
//jgw//	 * The following 2-D example shows down-sampling of a 7x7 grid (nx = 7,
//jgw//	 * ny = 7.  With ghost-cell padding the actual extents of the grid are 9x9.
//jgw//	 * Setting the strides in x and y to equal 2 results in an output grid of
//jgw//	 * nx = 4, ny = 4, with actual extents 6x6.
//jgw//	 *
  //jgw//   * G G G G G G G G G
  //jgw//   * G X X X X X X X G
  //jgw//   * G X X X X X X X G         G G G G G G
  //jgw//   * G X X X X X X X G         G X X X X G
  //jgw//   * G X X X X X X X G   ==>   G X X X X G
  //jgw//   * G X X X X X X X G         G X X X X G
  //jgw//   * G X X X X X X X G         G X X X X G
  //jgw//   * G X X X X X X X G         G G G G G G
  //jgw//   * G G G G G G G G G
  //jgw//   *
//jgw//	 * Note that grid extents in each dimension must be evenly divisible by
//jgw//	 * the stride for that dimension:
//jgw//	 *
//jgw//	 *   nx = 150;
//jgw//	 *   global->fdParams.stride_x = 10; // legal -> 150/10 = 15
//jgw//	 *
//jgw//	 *   global->fdParams.stride_x = 8; // illegal!!! -> 150/8 = 18.75
  //jgw//   *------------------------------------------------------------------------*/
//jgw//
//jgw//	// relative path to fields data from global header
//jgw//	sprintf(global->fdParams.baseDir, "fields");
//jgw//
//jgw//	// base file name for fields output
//jgw//	sprintf(global->fdParams.baseFileName, "fields");
//jgw//
//jgw//	global->fdParams.stride_x = 1;
//jgw//	global->fdParams.stride_y = 1;
//jgw//	global->fdParams.stride_z = 1;
//jgw//
//jgw//	// add field parameters to list
//jgw//	global->outputParams.push_back(&global->fdParams);
//jgw//
//jgw//	sim_log ( "Fields x-stride " << global->fdParams.stride_x );
//jgw//	sim_log ( "Fields y-stride " << global->fdParams.stride_y );
//jgw//	sim_log ( "Fields z-stride " << global->fdParams.stride_z );
//jgw//
//jgw//	// relative path to electron species data from global header
//jgw//	sprintf(global->hedParams.baseDir, "hydro");
//jgw//
//jgw//	// base file name for fields output
//jgw//	sprintf(global->hedParams.baseFileName, "ehydro");
//jgw//
//jgw//	global->hedParams.stride_x = 1;
//jgw//	global->hedParams.stride_y = 1;
//jgw//	global->hedParams.stride_z = 1;
//jgw//
//jgw//	// add electron species parameters to list
//jgw//	global->outputParams.push_back(&global->hedParams);
//jgw//
//jgw//	sim_log ( "Electron species x-stride " << global->hedParams.stride_x );
//jgw//	sim_log ( "Electron species y-stride " << global->hedParams.stride_y );
//jgw//	sim_log ( "Electron species z-stride " << global->hedParams.stride_z );
//jgw//
//jgw//	// relative path to electron species data from global header
//jgw//	sprintf(global->hHdParams.baseDir, "hydro");
//jgw//
//jgw//	// base file name for fields output
//jgw//	sprintf(global->hHdParams.baseFileName, "Hhydro");
//jgw//
//jgw//	global->hHdParams.stride_x = 1;
//jgw//	global->hHdParams.stride_y = 1;
//jgw//	global->hHdParams.stride_z = 1;
//jgw//
//jgw//	sim_log ( "Ion species x-stride " << global->hHdParams.stride_x );
//jgw//	sim_log ( "Ion species y-stride " << global->hHdParams.stride_y );
//jgw//	sim_log ( "Ion species z-stride " << global->hHdParams.stride_z );
//jgw//
//jgw//	// add electron species parameters to list
//jgw//	global->outputParams.push_back(&global->hHdParams);
//jgw//
  //jgw//  /*--------------------------------------------------------------------------
//jgw//	 * Set output fields
//jgw//	 *
//jgw//	 * It is now possible to select which state-variables are output on a
//jgw//	 * per-dump basis.  Variables are selected by passing an or-list of
//jgw//	 * state-variables by name.  For example, to only output the x-component
//jgw//	 * of the electric field and the y-component of the magnetic field, the
//jgw//	 * user would call output_variables like:
//jgw//	 *
//jgw//	 *   global->fdParams.output_variables( ex | cby );
//jgw//	 *
//jgw//	 * NOTE: OUTPUT VARIABLES ARE ONLY USED FOR THE BANDED FORMAT.  IF THE
//jgw//	 * FORMAT IS BAND-INTERLEAVE, ALL VARIABLES ARE OUTPUT AND CALLS TO
//jgw//	 * 'output_variables' WILL HAVE NO EFFECT.
//jgw//	 *
//jgw//	 * ALSO: DEFAULT OUTPUT IS NONE!  THIS IS DUE TO THE WAY THAT VPIC
//jgw//	 * HANDLES GLOBAL VARIABLES IN THE INPUT DECK AND IS UNAVOIDABLE.
//jgw//	 *
//jgw//	 * For convenience, the output variable 'all' is defined:
//jgw//	 *
//jgw//	 *   global->fdParams.output_variables( all );
  //jgw//   *------------------------------------------------------------------------*/
//jgw//	/* CUT AND PASTE AS A STARTING POINT
//jgw//	 * REMEMBER TO ADD APPROPRIATE GLOBAL DUMPPARAMETERS VARIABLE
//jgw//
  //jgw//  output_variables( all );
//jgw//
  //jgw//  output_variables( electric | div_e_err | magnetic | div_b_err |
  //jgw//                    tca      | rhob      | current  | rhof |
  //jgw//                    emat     | nmat      | fmat     | cmat );
//jgw//
  //jgw//  output_variables( current_density  | charge_density |
  //jgw//                    momentum_density | ke_density     | stress_tensor );
//jgw//	*/
//jgw//
//jgw//	//	global->fdParams.output_variables( electric | magnetic );
//jgw//	//global->hedParams.output_variables( current_density | charge_density );
//jgw//	//global->hHdParams.output_variables( current_density | charge_density );
//jgw//
//jgw//	global->fdParams.output_variables( all );
//jgw//	global->hedParams.output_variables( all );
//jgw//	global->hHdParams.output_variables( all );
//jgw//
//jgw//	/*--------------------------------------------------------------------------
//jgw//	 * Convenience functions for simlog output
//jgw//	 *------------------------------------------------------------------------*/
//jgw//
//jgw//	char varlist[512];
//jgw//	create_field_list(varlist, global->fdParams);
//jgw//
//jgw//	sim_log ( "Fields variable list: " << varlist );
//jgw//
//jgw//	create_hydro_list(varlist, global->hedParams);
//jgw//
//jgw//	sim_log ( "Electron species variable list: " << varlist );
//jgw//
//jgw//	create_hydro_list(varlist, global->hHdParams);
//jgw//
//jgw//	sim_log ( "Ion species variable list: " << varlist );
//jgw//
//jgw//
//jgw//	sim_log("*** Finished with user-specified initialization ***");
//jgw//
//jgw//
  //jgw//// Upon completion of the initialization, the following occurs:
  //jgw//// - The synchronization error (tang E, norm B) is computed between domains
  //jgw////   and tang E / norm B are synchronized by averaging where discrepancies
  //jgw////   are encountered.
  //jgw//// - The initial divergence error of the magnetic field is computed and
  //jgw////   one pass of cleaning is done (for good measure)
  //jgw//// - The bound charge density necessary to give the simulation an initially
  //jgw////   clean divergence e is computed.
  //jgw//// - The particle momentum is uncentered from u_0 to u_{-1/2}
  //jgw//// - The user diagnostics are called on the initial state
  //jgw//// - The physics loop is started
  //jgw////
  //jgw//// The physics loop consists of:
  //jgw//// - Advance particles from x_0,u_{-1/2} to x_1,u_{1/2}
  //jgw//// - User particle injection at x_{1-age}, u_{1/2} (use inject_particles)
  //jgw//// - User current injection (adjust field(x,y,z).jfx, jfy, jfz)
  //jgw//// - Advance B from B_0 to B_{1/2}
  //jgw//// - Advance E from E_0 to E_1
  //jgw//// - User field injection to E_1 (adjust field(x,y,z).ex,ey,ez,cbx,cby,cbz)
  //jgw//// - Advance B from B_{1/2} to B_1
  //jgw//// - (periodically) Divergence clean electric field
  //jgw//// - (periodically) Divergence clean magnetic field
  //jgw//// - (periodically) Synchronize shared tang e and norm b
  //jgw//// - Increment the time step
  //jgw//// - Call user diagnostics
  //jgw//// - (periodically) Print a status message

} //begin_initialization

//jgw//#define should_dump(x) \
//jgw//	(global->x##_interval>0 && remainder(step, global->x##_interval) == 0)
//jgw//
//jgw//#include <FileIO.hxx>

begin_diagnostics {

  //jgw//const int nsp=global->nsp;
  //jgw//const int nx=grid->nx;
  //jgw//const int ny=grid->ny;
  //jgw//const int nz=grid->nz;
//jgw//
//jgw//	/*--------------------------------------------------------------------------
//jgw//	 * NOTE: YOU CANNOT DIRECTLY USE C FILE DESCRIPTORS OR SYSTEM CALLS ANYMORE
//jgw//	 *
//jgw//	 * To create a new directory, use:
//jgw//	 *
//jgw//	 *   dump_mkdir("full-path-to-directory/directoryname")
//jgw//	 *
//jgw//	 * To open a file, use: FileIO class
//jgw//	 *
//jgw//	 * Example for file creation and use:
//jgw//	 *
//jgw//	 *   // declare file and open for writing
//jgw//	 *   // possible modes are: io_write, io_read, io_append,
//jgw//	 *   // io_read_write, io_write_read, io_append_read
//jgw//	 *   FileIO fileIO;
//jgw//	 *   FileIOStatus status;
//jgw//	 *   status= fileIO.open("full-path-to-file/filename", io_write);
//jgw//	 *
//jgw//	 *   // formatted ASCII  output
//jgw//	 *   fileIO.print("format string", varg1, varg2, ...);
//jgw//	 *
//jgw//	 *   // binary output
//jgw//	 *   // Write n elements from array data to file.
//jgw//	 *   // T is the type, e.g., if T=double
//jgw//	 *   // fileIO.write(double * data, size_t n);
//jgw//	 *   // All basic types are supported.
//jgw//	 *   fileIO.write(T * data, size_t n);
//jgw//	 *
//jgw//	 *   // close file
//jgw//	 *   fileIO.close();
  //jgw//   *------------------------------------------------------------------------*/
//jgw//
  //jgw//   /*--------------------------------------------------------------------------
//jgw//	 * Data output directories
//jgw//	 * WARNING: The directory list passed to "global_header" must be
//jgw//	 * consistent with the actual directories where fields and species are
//jgw//	 * output using "field_dump" and "hydro_dump".
//jgw//	 *
//jgw//	 * DIRECTORY PATHES SHOULD BE RELATIVE TO
//jgw//	 * THE LOCATION OF THE GLOBAL HEADER!!!
  //jgw//   *------------------------------------------------------------------------*/
//jgw//
//jgw//
  //jgw///*--------------------------------------------------------------------------
  //jgw// * Normal rundata dump
  //jgw// *------------------------------------------------------------------------*/
//jgw//	if(step==0) {
//jgw//		dump_mkdir("fields");
//jgw//		dump_mkdir("hydro");
//jgw//		dump_mkdir("rundata");
//jgw//		dump_mkdir("injectors");
//jgw//		dump_mkdir("restart0");
//jgw//		dump_mkdir("restart1");  // 1st backup
//jgw//		dump_mkdir("restart2");  // 2nd backup
//jgw//		dump_mkdir("particle");
//jgw//
//jgw//		dump_grid("rundata/grid");
//jgw//		dump_materials("rundata/materials");
//jgw//		dump_species("rundata/species");
//jgw//		global_header("global", global->outputParams);
//jgw//	} // if
//jgw//
//jgw//	/*--------------------------------------------------------------------------
//jgw//	 * Normal rundata energies dump
//jgw//	 *------------------------------------------------------------------------*/
//jgw//	if(should_dump(energies)) {
//jgw//		dump_energies("rundata/energies", step == 0 ? 0 : 1);
//jgw//	} // if
//jgw//
//jgw//	/*--------------------------------------------------------------------------
//jgw//	 * Field data output
//jgw//	 *------------------------------------------------------------------------*/
//jgw//
//jgw//	if(step == 1 || should_dump(fields)) field_dump(global->fdParams);
//jgw//
//jgw//	/*--------------------------------------------------------------------------
//jgw//	 * Electron species output
//jgw//	 *------------------------------------------------------------------------*/
//jgw//
//jgw//	if(should_dump(ehydro)) hydro_dump("electron", global->hedParams);
//jgw//
//jgw//	/*--------------------------------------------------------------------------
//jgw//	 * Ion species output
//jgw//	 *------------------------------------------------------------------------*/
//jgw//
//jgw//	if(should_dump(Hhydro)) hydro_dump("ion", global->hHdParams);
//jgw//
//jgw//	/*--------------------------------------------------------------------------
//jgw//	 * Restart dump
//jgw//	 *------------------------------------------------------------------------*/
//jgw//
//jgw//	if(step && !(step%global->restart_interval)) {
//jgw//		if(!global->rtoggle) {
//jgw//			global->rtoggle = 1;
//jgw//			dump_restart("restart1/restart", 0);
//jgw//			DUMP_INJECTORS(1);
//jgw//		}
//jgw//		else {
//jgw//			global->rtoggle = 0;
//jgw//			dump_restart("restart2/restart", 0);
//jgw//			DUMP_INJECTORS(2);
//jgw//		} // if
//jgw//	} // if
//jgw//
  //jgw//// Dump particle data
//jgw//
//jgw//	char subdir[36];
//jgw//	if ( should_dump(eparticle) && step !=0 && step > 56*(global->fields_interval)  ) {
//jgw//		  //	if ( should_dump(eparticle) && step !=0 ) {
//jgw//	  sprintf(subdir,"particle/T.%d",step);
//jgw//	  dump_mkdir(subdir);
//jgw//	  sprintf(subdir,"particle/T.%d/eparticle",step);
//jgw//	  dump_particles("electron",subdir);
//jgw//	}
//jgw//
//jgw//
//jgw////   if ( should_dump(Hparticle) ) {
//jgw////     dump_particles("ion",  "Hparticle");
//jgw////   }
//jgw//
  //jgw//// Shut down simulation when wall clock time exceeds global->quota_sec.
  //jgw//// Note that the mp_elapsed() is guaranteed to return the same value for all
  //jgw//// processors (i.e., elapsed time on proc #0), and therefore the abort will
  //jgw//// be synchronized across processors. Note that this is only checked every
  //jgw//// few timesteps to eliminate the expensive mp_elapsed call from every
  //jgw//// timestep. mp_elapsed has an ALL_REDUCE in it!
  //jgw//
  //jgw//  if( step>0 && global->quota_check_interval>0 && (step&global->quota_check_interval)==0 ) {
  //jgw//  if( mp_elapsed( grid->mp ) > global->quota_sec ) {
  //jgw//    sim_log( "Allowed runtime exceeded for this job.  Terminating....\n");
  //jgw//    dump_restart("restart0/restart",0);
  //jgw//    sim_log( "Restart dump restart completed." );
  //jgw//    DUMP_INJECTORS(0);
  //jgw//    mp_barrier( grid->mp ); // Just to be safe
  //jgw//    mp_finalize( grid->mp );
  //jgw//    exit(0); // Exit or abort?
  //jgw//  }
  //jgw//}

} // end diagnostics

// *******************  PARTICLE INJECTION  - OPEN BOUNDARY ***************************

begin_particle_injection {
  //jgw//int inject;
  //jgw//double x, y, z, age, flux, vtherm, vd;
  //jgw//double uv[3];
  //jgw//double zcell;
  //jgw//const int nsp=global->nsp;
  //jgw//const int nx=grid->nx;
  //jgw//const int ny=grid->ny;
  //jgw//const int nz=grid->nz;
  //jgw//const double rin[3]={global->rin[0],global->rin[1],global->rin[2]};
  //jgw//const double rout[3]={global->rout[0],global->rout[1],global->rout[2]};
  //jgw//const double sqpi =1.772453850905516;
  //jgw//const double dt=grid->dt;
  //jgw//const double hx=grid->dx;
  //jgw//const double hy=grid->dy;
  //jgw//const double hz=grid->dz;
  //jgw//const double nb=global->nb;
  //jgw//const double nfac=global->nfac;
//jgw//
  //jgw//// Initialize the injectors on the first call
//jgw//
  //jgw//  static int initted=0;
  //jgw//  if ( !initted ) {
//jgw//
  //jgw//    initted=1;
//jgw//
  //jgw//    if (rank() == 0) MESSAGE(("----------------Initializing the Particle Injectors-----------------"));
//jgw//
  //jgw//    // Intialize injectors for Harris Sheet with a uniform background
//jgw//
  //jgw//    if (global->right) {
//jgw//
//jgw//	DEFINE_INJECTOR(right,ny,nz);
//jgw//
//jgw//	if (step ==0) {
//jgw//	  for ( int n=1; n<=nsp; n++ ) {
//jgw//	    double cn = (uf(2)/vth(2))/(vth(n)/vth(2));
//jgw//	    for ( int k=1;k<=nz; k++ ) {
//jgw//	      for ( int j=1;j<=ny; j++ ) {
//jgw//		bright(n,k,j) = 0;
//jgw//		zcell = (grid->z0 + k*hz-hz/2)/(global->L_de);
//jgw//		nright(n,k,j) = (nb + 1/(cosh(zcell)*cosh(zcell)))/nfac;
//jgw//		fright(n,k,j) = (nb*vthb(n) + vth(n)/(cosh(zcell)*cosh(zcell)))/(2*hx*sqpi*nfac);
//jgw//		uright(1,n,k,j) = 0;
//jgw//		uright(2,n,k,j) = uf(n)/(1+nb*cosh(zcell)*cosh(zcell));
//jgw//		uright(3,n,k,j) = 0;
//jgw//		pright(1,2,n,k,j)=pright(2,1,n,k,j)=pright(1,3,n,k,j)=pright(3,1,n,k,j)=pright(2,3,n,k,j)=pright(3,2,n,k,j)=0;
//jgw//		pright(1,1,n,k,j) = (nb*vthb(n)*vthb(n) + vth(n)*vth(n)/(cosh(zcell)*cosh(zcell)))/(2*nfac);
//jgw//		pright(2,2,n,k,j) = (nb*vthb(n)*vthb(n) + vth(n)*vth(n)*(1/(cosh(zcell)*cosh(zcell))+2*nb*cn*cn/(1+nb*cosh(zcell)*cosh(zcell))))/(2*nfac);
//jgw//		pright(3,3,n,k,j) = pright(1,1,n,k,j);
//jgw//	      }
//jgw//	    }
//jgw//	  }  // end for
//jgw//	} // endif
//jgw//
//jgw//	else
//jgw//	  READ_INJECTOR(right,ny,nz,0);
//jgw//
  //jgw//    } //end right boundary
//jgw//
  //jgw//    if (global->left) {
//jgw//
//jgw//	DEFINE_INJECTOR(left,ny,nz);
//jgw//
//jgw//	if (step==0) {
//jgw//	  for ( int n=1; n<=nsp; n++ ) {
//jgw//	    double cn = (uf(2)/vth(2))/(vth(n)/vth(2));
//jgw//	    for ( int k=1;k<nz+1; k++ ) {
//jgw//	      for ( int j=1;j<=ny; j++ ) {
//jgw//		bleft(n,k,j) = 0;
//jgw//		zcell = (grid->z0 + k*hz-hz/2)/(global->L_de);
//jgw//		nleft(n,k,j) = (nb + 1/(cosh(zcell)*cosh(zcell)))/nfac;
//jgw//		fleft(n,k,j) = (nb*vthb(n) + vth(n)/(cosh(zcell)*cosh(zcell)))/(2*hx*sqpi*nfac);
//jgw//		uleft(1,n,k,j) = 0;
//jgw//		uleft(2,n,k,j) = uf(n)/(1+nb*cosh(zcell)*cosh(zcell));
//jgw//		uleft(3,n,k,j) = 0;
//jgw//		pleft(1,2,n,k,j)=pleft(2,1,n,k,j)=pleft(1,3,n,k,j)=pleft(3,1,n,k,j)=pleft(2,3,n,k,j)=pleft(3,2,n,k,j)=0;
//jgw//		pleft(1,1,n,k,j) = (nb*vthb(n)*vthb(n) + vth(n)*vth(n)/(cosh(zcell)*cosh(zcell)))/(2*nfac);
//jgw//		pleft(2,2,n,k,j) = (nb*vthb(n)*vthb(n) + vth(n)*vth(n)*(1/(cosh(zcell)*cosh(zcell))+2*nb*cn*cn/(1+nb*cosh(zcell)*cosh(zcell))))/(2*nfac);
//jgw//		pleft(3,3,n,k,j) = pleft(1,1,n,k,j);
//jgw//	      }
//jgw//	    }
//jgw//	  } // end for
//jgw//	} //endif
//jgw//
//jgw//	else
//jgw//	  READ_INJECTOR(left,ny,nz,0);
//jgw//
  //jgw//    } // end left boundary
//jgw//
  //jgw//    if (global->top) {
//jgw//
//jgw//	DEFINE_INJECTOR(top,ny,nx);
//jgw//
//jgw//	if (step==0) {
//jgw//	  for ( int n=1; n<=nsp; n++ ) {
//jgw//	    for ( int i=1;i<=nx; i++ ) {
//jgw//	      for ( int j=1;j<=ny; j++ ) {
//jgw//		btop(n,i,j) = 0;
//jgw//		ntop(n,i,j) = nb/nfac;
//jgw//		ftop(n,i,j) = ntop(n,i,j)*vthb(n)/(2*hz*sqpi);
//jgw//		utop(1,n,i,j) = 0;
//jgw//		utop(2,n,i,j) = 0;
//jgw//		utop(3,n,i,j) = 0;
//jgw//		ptop(1,2,n,i,j)=ptop(2,1,n,i,j)=ptop(1,3,n,i,j)=ptop(3,1,n,i,j)=ptop(2,3,n,i,j)=ptop(3,2,n,i,j)=0;
//jgw//		ptop(1,1,n,i,j) = ntop(n,i,j)*vthb(n)*vthb(n)/2;;
//jgw//		ptop(2,2,n,i,j) = ntop(n,i,j)*vthb(n)*vthb(n)/2;;
//jgw//		ptop(3,3,n,i,j) = ntop(n,i,j)*vthb(n)*vthb(n)/2;;
//jgw//	      }
//jgw//	    }
//jgw//	  } // end for
//jgw//	} //endif
//jgw//
//jgw//	else
//jgw//	  READ_INJECTOR(top,ny,nx,0);
//jgw//
  //jgw//    } // end top boundary
//jgw//
  //jgw//    if (global->bottom) {
//jgw//
//jgw//	DEFINE_INJECTOR(bot,ny,nx);
//jgw//
//jgw//	if (step ==0) {
//jgw//	  for ( int n=1; n<=nsp; n++ ) {
//jgw//	    for ( int i=1;i<=nx; i++ ) {
//jgw//	      for ( int j=1;j<=ny; j++ ) {
//jgw//		bbot(n,i,j) = 0;
//jgw//		nbot(n,i,j) = nb/nfac;
//jgw//		fbot(n,i,j) = nbot(n,i,j)*vthb(n)/(2*hz*sqpi);
//jgw//		ubot(1,n,i,j) = 0.0;
//jgw//		ubot(2,n,i,j) = 0.0;
//jgw//		ubot(3,n,i,j) = 0.0;
//jgw//		pbot(1,2,n,i,j)=pbot(2,1,n,i,j)=pbot(1,3,n,i,j)=pbot(3,1,n,i,j)=pbot(2,3,n,i,j)=pbot(3,2,n,i,j)=0;
//jgw//		pbot(1,1,n,i,j) = nbot(n,i,j)*vthb(n)*vthb(n)/2;
//jgw//		pbot(2,2,n,i,j) = nbot(n,i,j)*vthb(n)*vthb(n)/2;
//jgw//		pbot(3,3,n,i,j) = nbot(n,i,j)*vthb(n)*vthb(n)/2;
//jgw//	      }
//jgw//	    }
//jgw//	  } // end for
//jgw//	} //endif
//jgw//
//jgw//	else
//jgw//	  READ_INJECTOR(bot,ny,nx,0);
//jgw//
  //jgw//    }  // end bottom boundary
  //jgw//
  //jgw//    if (rank() == 0) MESSAGE(("-------------------------------------------------------------------"));
//jgw//
  //jgw//  }// End of Intialization
//jgw//
  //jgw//  //  Inject particles on Left Boundary
//jgw//
  //jgw//  if (global->left) {
  //jgw//    for ( int n=1; n<=nsp; n++ ) {
//jgw//	species_t * species = find_species_id(n-1,species_list );
//jgw//	for ( int k=1;k<=nz; k++ ) {
//jgw//	  for ( int j=1;j<=ny; j++ ) {
//jgw//	    bleft(n,k,j) = bleft(n,k,j) + dt*fleft(n,k,j);
//jgw//	    inject = (int) bleft(n,k,j);
//jgw//	    bleft(n,k,j) = bleft(n,k,j) - (double) inject;
//jgw//	    double uflow[3] = {uleft(1,n,k,j),uleft(2,n,k,j),uleft(3,n,k,j)};
//jgw//	    double press[9] = {pleft(1,1,n,k,j),pleft(1,2,n,k,j),pleft(1,3,n,k,j),pleft(2,1,n,k,j),pleft(2,2,n,k,j),pleft(2,3,n,k,j),pleft(3,1,n,k,j),pleft(3,2,n,k,j),pleft(3,3,n,k,j)};
//jgw//	    repeat(inject) {
//jgw//	      compute_injection(uv,nleft(n,k,j),uflow,press,1,2,3,rng);
//jgw//	      x = grid->x0;
//jgw//	      y = grid->y0 + hy*(j-1) + hy*uniform_rand(0,1);
//jgw//	      z = grid->z0 + hz*(k-1) + hz*uniform_rand(0,1);
//jgw//	      age = 0;
//jgw//	      inject_particle(species, x, y, z, uv[0], uv[1], uv[2], q(n), age, 1 );
//jgw//	    }
//jgw//	  }
//jgw//	}
  //jgw//    }
  //jgw//  } // end left injector
//jgw//
  //jgw//  //  Inject particles on Right Boundary
//jgw//
  //jgw//  if (global->right) {
  //jgw//    for ( int n=1; n<=nsp; n++ ) {
//jgw//	species_t * species = find_species_id(n-1,species_list );
//jgw//	for ( int k=1;k<=nz; k++ ) {
//jgw//	  for ( int j=1;j<=ny; j++ ) {
//jgw//	    bright(n,k,j) = bright(n,k,j) + dt*fright(n,k,j);
//jgw//	    inject = (int) bright(n,k,j);
//jgw//	    bright(n,k,j) = bright(n,k,j) - (double) inject;
//jgw//	    double uflow[3] = {uright(1,n,k,j),uright(2,n,k,j),uright(3,n,k,j)};
//jgw//	    double press[9] = {pright(1,1,n,k,j),pright(1,2,n,k,j),pright(1,3,n,k,j),pright(2,1,n,k,j),pright(2,2,n,k,j),pright(2,3,n,k,j),pright(3,1,n,k,j),pright(3,2,n,k,j),pright(3,3,n,k,j)};
//jgw//	    repeat(inject) {
//jgw//	      compute_injection(uv,nright(n,k,j),uflow,press,-1,2,3,rng);
//jgw//	      x = grid->x1;
//jgw//	      y = grid->y0 + hy*(j-1) + hy*uniform_rand(0,1);
//jgw//	      z = grid->z0 + hz*(k-1) + hz*uniform_rand(0,1);
//jgw//	      age = 0;
//jgw//	      inject_particle(species, x, y, z, uv[0], uv[1], uv[2], q(n), age, 1 );
//jgw//	    }
//jgw//	  }
//jgw//	}
  //jgw//    }
  //jgw//  } // end right injector
//jgw//
  //jgw//  //  Inject particles on Top Boundary
//jgw//
  //jgw//  if (global->top) {
  //jgw//    for ( int n=1; n<=nsp; n++ ) {
//jgw//	species_t * species = find_species_id(n-1,species_list );
//jgw//	for ( int i=1;i<=nx; i++ ) {
//jgw//	  for ( int j=1;j<=ny; j++ ) {
//jgw//
//jgw//	    vtherm = sqrt(2.0*ptop(3,3,n,i,j)/ntop(n,i,j));
//jgw//	    double t=grid->dt*step;
//jgw//	    double tau = global->tdrive;
//jgw//	    double vexb = (global->edrive)*(1-exp(-t/tau))/field(i,j,nz).cbx;
//jgw//	    vd = vexb/vtherm;
//jgw//	    btop(n,i,j) = btop(n,i,j) + dt*ntop(n,i,j)*vtherm*(exp(-vd*vd)/sqpi+vd*(erf(vd)+1))/(2*hz);
//jgw//
//jgw//	    //	    btop(n,i,j) = btop(n,i,j) + dt*ftop(n,i,j);
//jgw//	    inject = (int) btop(n,i,j);
//jgw//	    btop(n,i,j) = btop(n,i,j)- (double) inject;
//jgw//	    double uflow[3] = {0 ,0 , -vexb};
//jgw//
//jgw//	    //	    double uflow[3] = {utop(1,n,i,j),utop(2,n,i,j),utop(3,n,i,j)};
//jgw//	    double press[9] = {ptop(1,1,n,i,j),ptop(1,2,n,i,j),ptop(1,3,n,i,j),ptop(2,1,n,i,j),ptop(2,2,n,i,j),ptop(2,3,n,i,j),ptop(3,1,n,i,j),ptop(3,2,n,i,j),ptop(3,3,n,i,j)};
//jgw//	    repeat(inject) {
//jgw//	      compute_injection(uv,ntop(n,i,j),uflow,press,-3,2,1,rng);
//jgw//	      x = grid->x0 + hx*(i-1) + hx*uniform_rand(0,1) ;
//jgw//	      y = grid->y0 + hy*(j-1) + hy*uniform_rand(0,1);
//jgw//	      z = grid->z1;
//jgw//	      age=0;
//jgw//	      inject_particle(species, x, y, z, uv[0], uv[1], uv[2], q(n), age, 1 );
//jgw//	    }
//jgw//	  }
//jgw//	}
  //jgw//    }
  //jgw//  }  // end top injector
//jgw//
  //jgw//  //  Inject particles on Bottom Boundary
//jgw//
  //jgw//  if (global->bottom) {
  //jgw//    for ( int n=1; n<=nsp; n++ ) {
//jgw//	species_t * species = find_species_id(n-1,species_list );
//jgw//	for ( int i=1;i<=nx; i++ ) {
//jgw//	  for ( int j=1;j<=ny; j++ ) {
//jgw//
//jgw//	    vtherm = sqrt(2.0*pbot(3,3,n,i,j)/nbot(n,i,j));
//jgw//	    double t=grid->dt*step;
//jgw//	    double tau = global->tdrive;
//jgw//	    double vexb = (global->edrive)*(1-exp(-t/tau))/field(i,j,1).cbx;
//jgw//	    vd =   -vexb/vtherm;
//jgw//	    bbot(n,i,j) = bbot(n,i,j) + dt*nbot(n,i,j)*vtherm*(exp(-vd*vd)/sqpi+vd*(erf(vd)+1))/(2*hz);
//jgw//
//jgw//	    //	    bbot(n,i,j) = bbot(n,i,j) + dt*fbot(n,i,j);
//jgw//
//jgw//
//jgw//	    inject = (int) bbot(n,i,j);
//jgw//	    bbot(n,i,j) = bbot(n,i,j)- (double) inject;
//jgw//	    //	    double uflow[3] = {ubot(1,n,i,j),ubot(2,n,i,j),ubot(3,n,i,j)};
//jgw//	    double uflow[3] = {0 ,0 , vexb };
//jgw// 	    double press[9] = {pbot(1,1,n,i,j),pbot(1,2,n,i,j),pbot(1,3,n,i,j),pbot(2,1,n,i,j),pbot(2,2,n,i,j),pbot(2,3,n,i,j),pbot(3,1,n,i,j),pbot(3,2,n,i,j),pbot(3,3,n,i,j)};
//jgw// 	    repeat(inject) {
//jgw// 	      compute_injection(uv,nbot(n,i,j),uflow,press,3,2,1,rng);
//jgw// 	      x = grid->x0 + hx*(i-1) + hx*uniform_rand(0,1);
//jgw// 	      y = grid->y0 + hy*(j-1) + hy*uniform_rand(0,1);
//jgw//	      z = grid->z0;
//jgw//	      age = 0;
//jgw//	      inject_particle(species, x, y, z, uv[0], uv[1], uv[2], q(n), age, 1 );
//jgw//	    }
//jgw//	  }
//jgw//	}
  //jgw//    }
  //jgw//  } // end bottom injector
//jgw//
//jgw//
//jgw////  *******  Update the injector moments at every sort interval *********
  //jgw//
  //jgw//  double v[3];
  //jgw//  double u[3];
  //jgw//  double p[9];
  //jgw//
//jgw//#define icell(i,j,k) INDEX_FORTRAN_3(i,j,k,0,nx+1,0,ny+1,0,nz+1)
//jgw//#define v(i) v[INDEX_FORTRAN_1(i,1,3)]
//jgw//#define u(i) u[INDEX_FORTRAN_1(i,1,3)]
//jgw//#define p(i,j) p[INDEX_FORTRAN_2(i,j,1,3,1,3)]
//jgw//
//jgw////  Parameters for measuring moments  - BE CAREFUL - don't make too big or we will go off the node
//jgw//
//jgw// int noff = 1;   // Offset from edge - to measure moments
  //jgw//               // noff = 0  --> start with cell directly on boundary
//jgw//
//jgw// int nav = 2;    // How many cells to include in the "inward" direction in the averging
//jgw// int navin = 2;    // How many cells to include in the "inward" direction in the averging
//jgw//
//jgw////  Right boundary Moments
//jgw//
//jgw//
//jgw// if (global->right) {
  //jgw// for ( int n=1; n<=nsp; n++ ) {
  //jgw//   species_t * species = find_species_id(n-1,species_list );
  //jgw//   particle_t * part;
  //jgw//   if (remainder(step, global->sort[n-1]) == 0) {
  //jgw//     double npart;
  //jgw//     for ( int k=1;k<=nz; k++ ) {
//jgw//	 for ( int j=1;j<=ny; j++ ) {
//jgw//	   npart = 0;
//jgw//	   flux = 0;
//jgw//	   u[0] = u[1] = u[2] = 0;
//jgw//	   p[0] = p[1] = p[2] = p[3]= p[4] = p[5] = p[6]= p[7] = p[8] = 0;
//jgw//	   for ( int i=nx-noff; i>nx-nav-noff; i-- ){
//jgw//	     int nstart = species->partition[icell(i,j,k)];
//jgw//	     int nstop  = species->partition[icell(i,j,k)+1];
//jgw//	     int ncell  = nstop - nstart;
//jgw//	     npart = npart + ncell;
//jgw//	     for (int np=nstart; np<nstop ; np++) {
//jgw//	       part=&species->p[np];
//jgw//	       double gamma = sqrt(1.0+part->ux*part->ux + part->uy*part->uy + part->uz*part->uz);
//jgw//	       v(1) = part->ux;
//jgw//	       v(2) = part->uy;
//jgw//	       v(3) = part->uz;
//jgw//	       if (v(1) < 0) flux = flux - v(1)/gamma;
//jgw//	       for ( int a=1;a<=3; a++ ) {
//jgw//		 u(a) = u(a) + v(a);
//jgw//		 for ( int b=1;b<=3; b++ ) {
//jgw//		   p(a,b) = p(a,b) + v(a)*v(b);
//jgw//		 }
//jgw//	       }
//jgw//	     } // end particle loop for single cell
//jgw//	   } // end cells included for these moments
//jgw//
//jgw//	   if ( npart > 0 ) {
//jgw//	     fright(n,k,j) = (1.0-rout[1])*fright(n,k,j) + rout[1]*flux/(nav*hx);
//jgw//	     nright(n,k,j) = (1.0-rout[0])*nright(n,k,j) + rout[0]*npart/nav;
//jgw//	     for ( int a=1; a<=3; a++ ) {
//jgw//	       uright(a,n,k,j) = (1-rout[1])*uright(a,n,k,j) + rout[1]*u(a)/npart;
//jgw//	       for ( int b=1;b<=3; b++ ) {
//jgw//		 p(a,b) = (p(a,b) - u(a)*u(b)/npart)/nav;
//jgw//		 pright(a,b,n,k,j) = (1-rout[2])*pright(a,b,n,k,j) + rout[2]*p(a,b);
//jgw//	       }
//jgw//	     }
//jgw//	   }
//jgw//	 }
  //jgw//     }
  //jgw//   }
  //jgw// }
//jgw// }  // end right moment update
//jgw//
  //jgw////    Left boundary Moments
//jgw//
//jgw// if (global->left) {
  //jgw// for ( int n=1; n<=nsp; n++ ) {
  //jgw//   species_t * species = find_species_id(n-1,species_list );
  //jgw//   particle_t * part;
  //jgw//   if (remainder(step, global->sort[n-1]) == 0) {
  //jgw//     double npart;
  //jgw//     for ( int k=1;k<=nz; k++ ) {
//jgw//	 for ( int j=1;j<=ny; j++ ) {
//jgw//	   npart = 0;
//jgw//	   flux = 0;
//jgw//	   u[0] = u[1] = u[2] = 0;
//jgw//	   p[0] = p[1] = p[2] = p[3]= p[4] = p[5] = p[6]= p[7] = p[8] = 0;
//jgw//	   for ( int i=1+noff;i<=nav+noff; i++ ) {
//jgw//	     int nstart = species->partition[icell(i,j,k)];
//jgw//	     int nstop  = species->partition[icell(i,j,k)+1];
//jgw//	     int ncell  = nstop - nstart;
//jgw//	     npart = npart + ncell;
//jgw//	     for (int np=nstart; np < nstop ; np++) {
//jgw//	       part=&species->p[np];
//jgw//	       double gamma = sqrt(1.0+part->ux*part->ux + part->uy*part->uy + part->uz*part->uz);
//jgw//	       v(1) = part->ux;
//jgw//	       v(2) = part->uy;
//jgw//	       v(3) = part->uz;
//jgw//	       if (v(1) > 0) flux = flux + v(1)/gamma;
//jgw//	       for ( int a=1; a<=3; a++ ) {
//jgw//		 u(a) = u(a) + v(a);
//jgw//		 for ( int b=1;b<=3; b++ ) {
//jgw//		   p(a,b) = p(a,b) + v(a)*v(b);
//jgw//		 }
//jgw//	       }
//jgw//	     } // end particle loop for single cell
//jgw//	   } // end cells included for these moments
//jgw//
//jgw//	   if ( npart > 0 ) {
//jgw//	     fleft(n,k,j) = (1.0-rout[1])*fleft(n,k,j) + rout[1]*flux/(nav*hx);
//jgw//	     nleft(n,k,j) = (1.0-rout[0])*nleft(n,k,j) + rout[0]*npart/nav;
//jgw//	     for ( int a=1; a<=3; a++ ) {
//jgw//	       uleft(a,n,k,j) = (1-rout[1])*uleft(a,n,k,j) + rout[1]*u(a)/npart;
//jgw//	       for ( int b=1;b<=3; b++ ) {
//jgw//		 p(a,b) = (p(a,b) - u(a)*u(b)/npart)/nav;
//jgw//		 pleft(a,b,n,k,j) = (1-rout[2])*pleft(a,b,n,k,j) + rout[2]*p(a,b);
//jgw//	       }
//jgw//	     }
//jgw//	   }
//jgw//	 }
  //jgw//     }
  //jgw//   }
  //jgw// }
//jgw//}  // end left moment update
//jgw//
  //jgw////    Top boundary Moments
//jgw//
//jgw// if (global->top) {
  //jgw// for ( int n=1; n<=nsp; n++ ) {
  //jgw//   species_t * species = find_species_id(n-1,species_list );
  //jgw//   particle_t * part;
  //jgw//   if (remainder(step, global->sort[n-1]) == 0) {
  //jgw//     double npart;
  //jgw//     for ( int i=1;i<=nx; i++ )
//jgw//	 for ( int j=1;j<=ny; j++ ) {
//jgw//	   npart = 0;
//jgw//	   flux = 0;
//jgw//	   u[0] = u[1] = u[2] = 0;
//jgw//	   p[0] = p[1] = p[2] = p[3]= p[4] = p[5] = p[6]= p[7] = p[8] = 0;
//jgw//	   for ( int k=nz-noff; k>nz-navin-noff; k-- ) {
//jgw//	     int nstart = species->partition[icell(i,j,k)];
//jgw//	     int nstop  = species->partition[icell(i,j,k)+1];
//jgw//	     int ncell  = nstop - nstart;
//jgw//	     npart = npart + ncell;
//jgw//	     for (int np=nstart; np < nstop ; np++) {
//jgw//	       part=&species->p[np];
//jgw//	       double gamma = sqrt(1.0+part->ux*part->ux + part->uy*part->uy + part->uz*part->uz);
//jgw//	       v(1) = part->ux;
//jgw//	       v(2) = part->uy;
//jgw//	       v(3) = part->uz;
//jgw//	       if (v(3) < 0) flux = flux - v(3)/gamma;
//jgw//	       for ( int a=1; a<=3; a++ ) {
//jgw//		 u(a) = u(a) + v(a);
//jgw//		 for ( int b=1;b<=3; b++ ) {
//jgw//		   p(a,b) = p(a,b) + v(a)*v(b);
//jgw//		 }
//jgw//	       }
//jgw//	     } // end particle loop for single cell
//jgw//	   } // end cells included for these moments
//jgw//
//jgw//	   if ( npart > 0 ) {
//jgw//	     ftop(n,i,j) = (1.0-rin[1])*ftop(n,i,j) + rin[1]*flux/(navin*hz);
//jgw//
//jgw////	     if ( npart/navin < ntop(n,i,j) ) ftop(n,i,j) = (ntop(n,i,j)- npart/navin)/dt; else ftop(n,i,j)=0;
//jgw//
//jgw//	     ntop(n,i,j) = (1-rin[0])*ntop(n,i,j) + rin[0]*npart/navin;
//jgw//	     for ( int a=1;a<=3; a++ ) {
//jgw//	       utop(a,n,i,j) = (1-rin[1])*utop(a,n,i,j) + rin[1]*u(a)/npart;
//jgw//	       for ( int b=1;b<=3; b++ ) {
//jgw//		 p(a,b) = (p(a,b) - v(a)*v(b)/npart)/navin;
//jgw//		 ptop(a,b,n,i,j) = (1-rin[2])*ptop(a,b,n,i,j) + rin[2]*p(a,b);
//jgw//	       }
//jgw//	     }
//jgw//	   }
//jgw//	 }
  //jgw//   }
  //jgw// }
//jgw// }  // end bottom moment update
//jgw//
//jgw// if (global->bottom) {
  //jgw// for ( int n=1; n<=nsp; n++ ) {
  //jgw//   species_t * species = find_species_id(n-1,species_list );
  //jgw//   particle_t * part;
  //jgw//   if (remainder(step, global->sort[n-1]) == 0) {
  //jgw//     double npart;
  //jgw//     for ( int i=1;i<=nx; i++ )
//jgw//	 for ( int j=1;j<=ny; j++ ) {
//jgw//	   npart = 0;
//jgw//	   flux = 0;
//jgw//	   u[0] = u[1] = u[2] = 0;
//jgw//	   p[0] = p[1] = p[2] = p[3]= p[4] = p[5] = p[6]= p[7] = p[8] = 0;
//jgw//	   for ( int k=1+noff;k<=navin+noff; k++ ) {
//jgw//	     int nstart = species->partition[icell(i,j,k)];
//jgw//	     int nstop  = species->partition[icell(i,j,k)+1];
//jgw//	     int ncell  = nstop - nstart;
//jgw//	     npart = npart + ncell;
//jgw//	     for (int np=nstart; np < nstop ; np++) {
//jgw//	       part=&species->p[np];
//jgw//	       double gamma = sqrt(1.0+part->ux*part->ux + part->uy*part->uy + part->uz*part->uz);
//jgw//	       v(1) = part->ux;
//jgw//	       v(2) = part->uy;
//jgw//	       v(3) = part->uz;
//jgw//	       if (v(3) > 0) flux = flux + v(3)/gamma;
//jgw//	       for ( int a=1; a<=3; a++ ) {
//jgw//		 u(a) = u(a) + v(a);
//jgw//		 for ( int b=1;b<=3; b++ ) {
//jgw//		   p(a,b) = p(a,b) + v(a)*v(b);
//jgw//		 }
//jgw//	       }
//jgw//	     } // end particle loop for single cell
//jgw//	   } // end cells included for these moments
//jgw//
//jgw//	   if ( npart > 0) {
//jgw//	     fbot(n,i,j) = (1.0-rin[1])*fbot(n,i,j) + rin[1]*flux/(navin*hz);
//jgw//	     //	     if ( npart/navin < nbot(n,i,j) ) fbot(n,i,j) = (nbot(n,i,j)- npart/navin)/dt; else fbot(n,i,j)=0;
//jgw//	     nbot(n,i,j) = (1-rin[0])*nbot(n,i,j) + rin[0]*npart/navin;
//jgw//	     for ( int a=1;a<=3; a++ ) {
//jgw//	       ubot(a,n,i,j) = (1-rin[1])*ubot(a,n,i,j) + rin[1]*u(a)/npart;
//jgw//	       for ( int b=1;b<=3; b++ ) {
//jgw//		 p(a,b) = (p(a,b) - v(a)*v(b)/npart)/navin;
//jgw//		 pbot(a,b,n,i,j) = (1-rin[2])*pbot(a,b,n,i,j) + rin[2]*p(a,b);
//jgw//	       }
//jgw//	     }
//jgw//	   }
//jgw//	 }
  //jgw//   }
  //jgw// }
//jgw// }  // end bottom moment update
//jgw//
//jgw//
//jgw////  Periodically save injector moments on outflow boundaries
//jgw////  Only do this on the outflow boundaries, and only if we have
//jgw////  a single domain on each boundary - otherwise would have to combine data files.
//jgw//
//jgw// if ( global->topology_y == 1 && global->topology_z ==1 ) {
//jgw//
//jgw//// How often to write moments to file -
//jgw//
  //jgw// int nskip = 10;
//jgw//
  //jgw// if (global->left) {
  //jgw//   int j = 1;
  //jgw//   for ( int n=1; n<=nsp; n++ ) {
  //jgw//     if (remainder(step, nskip*global->sort[n-1]) == 0) {
//jgw//	 char buffer[20];
//jgw//	 sprintf(buffer, "injectors/left%i.dat", n);
//jgw//	 FileIO fileIO;
//jgw//	 FileIOStatus status;
//jgw//	 status= fileIO.open(buffer, io_append);
//jgw//	 for ( int k=1;k<=nz; k++ ) {
//jgw//	   zcell = (grid->z0 + k*hz-hz/2)/(global->L_de);
//jgw//	   fileIO.print("%6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g \n", zcell,nleft(n,k,j),uleft(1,n,k,j),uleft(2,n,k,j),uleft(3,n,k,j),pleft(1,1,n,k,j),pleft(2,2,n,k,j),pleft(3,3,n,k,j),pleft(1,2,n,k,j),pleft(1,3,n,k,j),pleft(2,3,n,k,j));
//jgw//	 } //end for
//jgw//	 fileIO.print("  \n \n");
//jgw//	 fileIO.close();
  //jgw//     }
  //jgw//   }
  //jgw// }  //end left output
//jgw//
  //jgw// if (global->right) {
  //jgw//   int j = 1;
  //jgw//   for ( int n=1; n<=nsp; n++ ) {
  //jgw//     if (remainder(step, nskip*global->sort[n-1]) == 0) {
//jgw//	 char buffer[20];
//jgw//	 sprintf(buffer, "injectors/right%i.dat", n);
//jgw//	 FileIO fileIO;
//jgw//	 FileIOStatus status;
//jgw//	 status= fileIO.open(buffer, io_append);
//jgw//	 for ( int k=1;k<=nz; k++ ) {
//jgw//	   zcell = (grid->z0 + k*hz-hz/2)/(global->L_de);
//jgw//	   fileIO.print("%6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g %6.4g \n", zcell,nright(n,k,j),uright(1,n,k,j),uright(2,n,k,j),uright(3,n,k,j),pright(1,1,n,k,j),pright(2,2,n,k,j),pright(3,3,n,k,j),pright(1,2,n,k,j),pright(1,3,n,k,j),pright(2,3,n,k,j));
//jgw//	 } //end for
//jgw//	 fileIO.print("  \n \n");
//jgw//	 fileIO.close();
  //jgw//     }
  //jgw//   }
  //jgw// }  //end right output
//jgw//
//jgw// } //end output for injector moments

} // end particle injection

//   *******************  CURRENT INJECTION ***************************

begin_current_injection {

  // No current injection for this simulation

}

//   *******************  FIELD INJECTION ***************************

begin_field_injection {

  //jgw//const int nx=grid->nx;
  //jgw//const int ny=grid->ny;
  //jgw//const int nz=grid->nz;
  //jgw//double t=grid->dt*step;
  //jgw//double tau = global->tdrive;
  //jgw//int x,y,z;
//jgw//
//jgw////   There macros are from local.c to apply boundary conditions
//jgw//
//jgw// #define XYZ_LOOP(xl,xh,yl,yh,zl,zh)		\
  //jgw// for( z=zl; z<=zh; z++ )			\
  //jgw//   for( y=yl; y<=yh; y++ )			\
  //jgw//     for( x=xl; x<=xh; x++ )
//jgw//
//jgw//#define xy_EDGE_LOOP(z) XYZ_LOOP(1,nx,1,ny+1,z,z)
//jgw//#define yx_EDGE_LOOP(z) XYZ_LOOP(1,nx+1,1,ny,z,z)
//jgw//
  //jgw// // Top Boundary
//jgw//
  //jgw// if (global->top) {
//jgw//
  //jgw//   yx_EDGE_LOOP(nz+1) field(x,y,z).ey = (global->edrive)*(1-exp(-t/tau));
  //jgw//   xy_EDGE_LOOP(nz+1) field(x,y,z).ex = -(global->edrive)*(1-exp(-t/tau))*global->bg;
//jgw//
  //jgw// }
//jgw//
  //jgw// // Bottom Boundary
//jgw//
  //jgw// if (global->bottom) {
//jgw//
  //jgw//   yx_EDGE_LOOP(1) field(x,y,z).ey = (global->edrive)*(1-exp(-t/tau));
  //jgw//   xy_EDGE_LOOP(1) field(x,y,z).ex = (global->edrive)*(1-exp(-t/tau))*global->bg;
//jgw//
  //jgw//
  //jgw//}
//jgw//
}  // end field injection

//  Collisional algorithm

//jgw//#include "collisions"
begin_particle_collisions {
}
