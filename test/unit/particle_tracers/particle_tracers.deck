// Test creation of tracer species with unique IDs

#include <unordered_set>

begin_globals {
};

inline int rank() {
  return _world_rank;
}

//=============================================================================
// Test whether the number of tracers is correct
//=============================================================================
int test_tracer_copy_count(species_t* tracer, int mincount, int maxcount, int _world_rank) {
  if((tracer->np < mincount) || (tracer->np > maxcount)) {
    sim_log("FAIL: Did not select the expected number of particles. Expected " << tracer->np << " in [" << mincount << "," << maxcount << "]");
    return 3;
  } else {
    sim_log("info: " << tracer->name << " has " << tracer->np << " particles");
    return 0;
  }
}

//=============================================================================
// Test whether the weight is 0.0 for copied tracers 
//=============================================================================
int test_tracer_copy_weight(species_t* tracer, int _world_rank) {
  for(int i = 0; i<tracer->np; i++) {
    if(tracer->k_p_h(i, particle_var::w) != 0.) {
      sim_log("FAIL: "<< tracer->name <<" did not have zero weight");
      return 4;
    }
  }
  sim_log("info: "<< tracer->name <<" has zero weight");
  return 0;
}

//=============================================================================
// Verify that all tracer IDs are unique 
//=============================================================================
int test_tracer_ids(species_t* tracer, int _world_rank) {
  std::unordered_set<size_t> IDs;
  sim_log("info: testing with VPIC_ENABLE_TRACER_PARTICLES");
  if(!tracer->using_annotations || tracer->annotation_vars.i64_vars.size() < 1) {
    sim_log("FAIL: "<< tracer->name <<" has no annotations for IDs");
    return 5;
  } else {
    sim_log("info: "<< tracer->name <<" should have unique IDs");
  }
  // Check for duplicates. Touch all IDs also verifies memory allocation
  IDs.clear();
  for(int i = 0; i<tracer->np; i++) {
    size_t id = tracer->annotations_h.get<int64_t>(i, 0);
    if(IDs.count(id) != 0) {
      sim_log("FAIL: particle "<< i <<" in "<< tracer->name <<" has duplicate ID "<< id);
      return 6;
    }
    IDs.insert(id);
  }
  if(IDs.size() != static_cast<uint32_t>(tracer->np)) {
    sim_log("FAIL: "<< IDs.size() << " IDs but"<< tracer->np <<" particles in "<<tracer->name);
    return 7;
  } else {
    sim_log("info: IDs of "<< tracer->name << " look reasonable");
  }
  return 0;
}

//=============================================================================
// Test wether tracer particles were copied correctly 
//=============================================================================
int test_tracer_copy(species_t* parent, species_t* tracer, int _world_rank) {
  bool success = true;
  for(int i=0; i<tracer->np; i++) {
    int j=0;
    success = false;
    for(j=0; j<parent->np; j++) {
      if(parent->p[j].dx == tracer->p[i].dx &&
         parent->p[j].dy == tracer->p[i].dy &&
         parent->p[j].dz == tracer->p[i].dz &&
         parent->p[j].ux == tracer->p[i].ux &&
         parent->p[j].uy == tracer->p[i].uy &&
         parent->p[j].uz == tracer->p[i].uz &&
         parent->p[j].i == tracer->p[i].i) {
        success = true;
        break;
      }
    }
    if(!success) {
      sim_log("FAIL: Tracer " << j << " not properly copied from parent species\n"); 
      sim_log("FAIL: dx: " << tracer->p[i].dx << "\n");
      sim_log("FAIL: dy: " << tracer->p[i].dy << "\n");
      sim_log("FAIL: dz: " << tracer->p[i].dz << "\n");
      sim_log("FAIL: ux: " << tracer->p[i].ux << "\n");
      sim_log("FAIL: uy: " << tracer->p[i].uy << "\n");
      sim_log("FAIL: uz: " << tracer->p[i].uz << "\n");
      sim_log("FAIL: w: "  << tracer->p[i].w << "\n");
      sim_log("FAIL: i: "  << tracer->p[i].i << "\n");
      return 8;
      break;
    }
  }
  if(success) {
    sim_log("info: All tracers properly copied from parent species\n");
  } else {
    sim_log("FAIL: Tracers (" << tracer->name << ") not properly copied from parent (" << parent->name << ") species\n");
    return 8;
  }
  return 0;
}

//=============================================================================
// Test whether the number of moved tracers is correct
//=============================================================================
int test_tracer_move_count(species_t* parent, species_t* tracer, int mincount, int maxcount, int oldcount, int _world_rank) {
  if((tracer->np < mincount) || (tracer->np > maxcount)) {
    sim_log("FAIL: Did not move the correct number of particles. " << tracer->np << " should be in [" << mincount << "," << maxcount << "]");
    return 9;
  } else {
    sim_log("info: " << tracer->name << " has " << tracer->np << " particles");
  }

  if(parent->np + tracer->np != oldcount) {
    sim_log("FAIL: Particle number not conserved in move from "<< parent->name <<" to "<< tracer->name <<". Before we had "<< oldcount <<" particles, now we have "<< parent->np <<"+"<< tracer->np);
    return 10;
  } else {
    sim_log(parent->name <<" now has "<< parent->np <<" particles");
  }
  return 0;
}

//=============================================================================
// Test whether the weight is correct for moved tracers
//=============================================================================
int test_tracer_move_weight(species_t* tracer, float weight, int _world_rank) {
  for(int i = 0; i<tracer->np; i++) {
    if(tracer->k_p_h(i, particle_var::w) != weight) {
      sim_log("FAIL: particle "<< i << " in species " << tracer->name <<" has weight "<< tracer->k_p_h(i, particle_var::w) <<" instead of "<< weight); 
      return 11;
    }
  }
  sim_log("info: "<< tracer->name <<" has correct weight");
  return 0;
}

//=============================================================================
// Test wether tracer particles were moved correctly 
//=============================================================================
int test_tracer_move(species_t* parent, species_t* tracer, int _world_rank) {
  bool found = false;
  for(int i=0; i<tracer->np; i++) {
    int j=0;
    found = false;
    for(j=0; j<parent->np; j++) {
      if(parent->p[j].dx == tracer->p[i].dx &&
         parent->p[j].dy == tracer->p[i].dy &&
         parent->p[j].dz == tracer->p[i].dz &&
         parent->p[j].ux == tracer->p[i].ux &&
         parent->p[j].uy == tracer->p[i].uy &&
         parent->p[j].uz == tracer->p[i].uz &&
         parent->p[j].i == tracer->p[i].i) {
        found = true;
        break;
      }
    }
    if(found) {
      sim_log("FAIL: Tracer " << j << " not properly moved from parent species\n"); 
      sim_log("FAIL: dx: " << tracer->p[i].dx << "\n");
      sim_log("FAIL: dy: " << tracer->p[i].dy << "\n");
      sim_log("FAIL: dz: " << tracer->p[i].dz << "\n");
      sim_log("FAIL: ux: " << tracer->p[i].ux << "\n");
      sim_log("FAIL: uy: " << tracer->p[i].uy << "\n");
      sim_log("FAIL: uz: " << tracer->p[i].uz << "\n");
      sim_log("FAIL: w: "  << tracer->p[i].w << "\n");
      sim_log("FAIL: i: "  << tracer->p[i].i << "\n");
      return 12;
      break;
    }
  }
  if(!found) {
    sim_log("info: All tracers properly moved from parent species\n");
  } else {
    sim_log("FAIL: Tracers (" << tracer->name << ") not properly movied from parent (" << parent->name << ") species\n");
    return 8;
  }
  return 0;
}

begin_initialization {

  // use natural PIC units
  double ec   = 1;        // Charge normalization
  double me   = 1;        // Mass normalization
  double c    = 1;        // Speed of light
  double de   = 1;        // Length normalization (electron inertial length)
  double eps0 = 1;        // Permittivity of space

  // simulation settings
  double uthe   = 0.1*c;  // Electron thermal speed
  double L      = 1*de;   // Box size
  double weight = 1.e6;   // Statistical weight of a macro particle
  int nstep     = 1;      // Number of timesteps
  int Ne        = 123456; // Number of electrons

  define_units(c, eps0);
  define_timestep( 0.01 );
  define_periodic_grid(  0,  0,  0,   // Grid low corner
                         L,  L,  L,   // Grid high corner
                        10, 10, 10,   // Grid resolution
                         1,  1,  1 ); // Processor configuration
  define_material("vacuum",1.0,1.0,0.0);
  define_field_array();

  species_t * electron = define_species( "electron", -ec, me, 1.5*Ne/nproc(), -1, 20, 1 );

  repeat(Ne) inject_particle( electron,
                              uniform( rng(0), 0, L ),   // Random location
                              uniform( rng(0), 0, L ),
                              uniform( rng(0), 0, L ),
                              normal( rng(0), 0, uthe ), // Random thermal velocity
                              normal( rng(0), 0, uthe ),
                              normal( rng(0), 0, uthe ),
                              weight,                    // Statistical weight
                              0, 0 );

  if(electron->np != Ne) {
    sim_log("FAIL: wrong number of particles in the donor species"); abort(1);
  } else {
    sim_log("info: donor species has "<< electron->np << " particles");
  }

  electron->copy_to_device();

  int err_code = 0;
  int mincount,maxcount;
  std::unordered_set<size_t> IDs;

  //===========================================================================
  // Copy out 1 percent of all particles.
  //===========================================================================
  species_t * elec_tracer = define_tracer_species_by_percentage("electron_tracers_percentage", electron, TracerType::Copy, 1.0);

  if(!elec_tracer) {
    sim_log("Creation of tracer species containing 1%% of particles failed"); abort(2);
  }

  //That should be 1234.56 particles, but of course it will produce an int.
  //Rounding up or down is both reasonable.
  mincount = floor(Ne*0.01);
  maxcount = ceil(Ne*0.01);
  err_code = test_tracer_copy_count(elec_tracer, mincount, maxcount, rank());
  if(err_code)
    abort(err_code);

  // Statistical weight of copies should be zero. Accessing particles also
  // verifies that memory allocation happend ok.
  err_code = test_tracer_copy_weight(elec_tracer, rank());
  if(err_code)
    abort(err_code);

  // All particles should have unique IDs, at least if the code was compiled with GLOBAL_PARTICLE_ID
  #ifdef VPIC_ENABLE_TRACER_PARTICLES
    err_code = test_tracer_ids(elec_tracer, rank());
    if(err_code)
      abort(err_code);
    err_code = test_tracer_copy(electron, elec_tracer, rank());
    if(err_code)
      abort(err_code);
  #else
    sim_log("info: testing without VPIC_ENABLE_TRACER_PARTICLES");
  #endif
  sim_log("info: "<< elec_tracer->name <<" done");

  //===========================================================================
  // Copy out 1 in 99.5 particle
  //===========================================================================
  species_t * elec_tracer2 = define_tracer_species_by_nth("electron_tracers_nth", electron, TracerType::Copy, 99.5);
  if(!elec_tracer2) {
    sim_log("Creation of tracer2 species containing 1%% of particles failed"); abort(9);
  }

  //That should be 1240.76 particles, but of course it will produce an int.
  //Rounding up or down is both reasonable.
  mincount = floor(Ne/99.5);
  maxcount = ceil(Ne/99.5);
  err_code = test_tracer_copy_count(elec_tracer2, mincount, maxcount, rank());
  if(err_code)
    abort(err_code);

  // Statistical weight of copies should be zero. Accessing particles also
  // verifies that memory allocation happend ok.
  err_code = test_tracer_copy_weight(elec_tracer2, rank());
  if(err_code)
    abort(err_code);

  // All particles should have unique IDs, at least if the code was compiled with GLOBAL_PARTICLE_ID
  #ifdef VPIC_ENABLE_TRACER_PARTICLES
    err_code = test_tracer_ids(elec_tracer2, rank());
    if(err_code)
      abort(err_code);
    err_code = test_tracer_copy(electron, elec_tracer2, rank());
    if(err_code)
      abort(err_code);
  #else
    sim_log("info: testing without VPIC_ENABLE_TRACER_PARTICLES");
  #endif
  sim_log("info: "<< elec_tracer2->name <<" done");

  //===========================================================================
  // Copy out 1237 of all particles.
  // This is a prime slightly larger than 1234.56 aka 1 percent
  //===========================================================================
  species_t * elec_tracer3 = define_tracer_species_with_n("electron_tracer_n", electron, TracerType::Copy, 1237);
  if(!elec_tracer3) {
    sim_log("Creation of tracer3 species containing 1237 of particles failed"); abort(16);
  }

  // This time we have limited on the acceptable number of tracers
  err_code = test_tracer_copy_count(elec_tracer3, 1237, 1237, rank());
  if(err_code)
    abort(err_code);

  // Statistical weight of copies should be zero. Accessing particles also
  // verifies that memory allocation happend ok.
  err_code = test_tracer_copy_weight(elec_tracer3, rank());
  if(err_code)
    abort(err_code);

  // All particles should have unique IDs, at least if the code was compiled with GLOBAL_PARTICLE_ID
  #ifdef VPIC_ENABLE_TRACER_PARTICLES
    err_code = test_tracer_ids(elec_tracer3, rank());
    if(err_code)
      abort(err_code);
    err_code = test_tracer_copy(electron, elec_tracer3, rank());
    if(err_code)
      abort(err_code);
  #else
    sim_log("info: testing without VPIC_GLOBAL_PARTICLE_ID");
  #endif
  sim_log("info: "<< elec_tracer3->name <<" done");

  //===========================================================================
  // Copy out particles based on a predicate
  //===========================================================================
  std::function<bool(particle_t)> my_predicate = [=](particle_t p) -> bool {
    //if (p.i % 100 == 23) { return true; }
    //else { return false; }
    if (p.ux < 0.) { return false; }
    if (p.uy < 0.) { return false; }
    if (p.uz < 0.) { return false; }
    return true;
  };
  species_t* elec_tracer4 = define_tracer_species_by_predicate( "electron_tracer_predicate",
                                                                electron,
                                                                TracerType::Copy,
                                                                my_predicate);
  if(!elec_tracer4) {
    sim_log("Creation of tracer4 species containing 1237 of particles failed"); abort(23);
  }

  // This time it is harder to figure out how many particles we should have.
  // About 1/8 of particles should have three positive velocity components, but
  // the actual values are randomly distributed. Instead of fixing the random
  // seed and trusting that the random numnbers don't change, I will accept
  // anything within 3 sigmas of the expected numnber, assuming a poisson
  // distribution.
  mincount = floor(Ne/8. - 3.*sqrt(Ne/8.));
  maxcount = ceil(Ne/8. + 3.*sqrt(Ne/8.));
  err_code = test_tracer_copy_count(elec_tracer4, mincount, maxcount, rank());
  if(err_code)
    abort(err_code);

  // Statistical weight of copies should be zero. Accessing particles also
  // verifies that memory allocation happend ok.
  err_code = test_tracer_copy_weight(elec_tracer4, rank());
  if(err_code)
    abort(err_code);

  // All particles should have unique IDs, at least if the code was compiled with GLOBAL_PARTICLE_ID
  #ifdef VPIC_ENABLE_TRACER_PARTICLES
    err_code = test_tracer_ids(elec_tracer4, rank());
    if(err_code)
      abort(err_code);
    err_code = test_tracer_copy(electron, elec_tracer4, rank());
    if(err_code)
      abort(err_code);
  #else
    sim_log("info: testing without VPIC_GLOBAL_PARTICLE_ID");
  #endif
  sim_log("info: "<< elec_tracer4->name <<" done");

  //===========================================================================
  // Move out 1 percent of all particles.
  //===========================================================================
  int oldcount = electron->np;
  species_t * elec_tracer5 = define_tracer_species_by_percentage("electron_tracers_percentage_move", electron, TracerType::Move, 1.0);
  if(!elec_tracer5) {
    sim_log("Creation of tracer5 species containing 1%% of particles failed"); abort(30);
  }

  //That should be 1234.56 particles, but of course it will produce an int.
  //Rounding up or down is both reasonable.
  mincount = floor(Ne*0.01);
  maxcount = ceil(Ne*0.01);
  err_code = test_tracer_move_count(electron, elec_tracer5, mincount, maxcount, oldcount, rank());
  if(err_code)
    abort(err_code);

  // Moving should leave the statistical weight unchanged. Also touching all
  // particles verifies that memory allocation happend ok.
  err_code = test_tracer_move_weight(elec_tracer5, weight, rank());
  if(err_code)
    abort(err_code);

  // All particles should have unique IDs, at least if the code was compiled with GLOBAL_PARTICLE_ID
  #ifdef VPIC_ENABLE_TRACER_PARTICLES
    err_code = test_tracer_ids(elec_tracer5, rank());
    if(err_code) 
      abort(err_code);
  #else
    sim_log("info: testing without VPIC_GLOBAL_PARTICLE_ID");
  #endif
  sim_log("info: "<< elec_tracer5->name <<" done");

  repeat(oldcount-electron->np) inject_particle( electron,
                              uniform( rng(0), 0, L ),   // Random location
                              uniform( rng(0), 0, L ),
                              uniform( rng(0), 0, L ),
                              normal( rng(0), 0, uthe ), // Random thermal velocity
                              normal( rng(0), 0, uthe ),
                              normal( rng(0), 0, uthe ),
                              weight,                    // Statistical weight
                              0, 0 );

  //===========================================================================
  // Move out 1 in 99.5 particle
  //===========================================================================
  oldcount = electron->np;
  species_t * elec_tracer6 = define_tracer_species_by_nth("electron_tracers_nth_move", electron, TracerType::Move, 99.5);
  if(!elec_tracer6) {
    sim_log("Creation of tracer6 species containing 1 in 99.5 of particles failed"); abort(9);
  }

  //That should be 1240.76 tracer particles, but of course it will produce an int.
  //Rounding up or down is both reasonable.
  mincount = floor(Ne/99.5);
  maxcount = ceil(Ne/99.5);
  err_code = test_tracer_move_count(electron, elec_tracer6, mincount, maxcount, oldcount, rank());
  if(err_code)
    abort(err_code);

  // Moving should leave the statistical weight unchanged. Also touching all
  // particles verifies that memory allocation happend ok.
  err_code = test_tracer_move_weight(elec_tracer6, weight, rank());
  if(err_code)
    abort(err_code);

  // All particles should have unique IDs, at least if the code was compiled with GLOBAL_PARTICLE_ID
  #ifdef VPIC_ENABLE_TRACER_PARTICLES
    // Test if Tracer IDs are unique
    err_code = test_tracer_ids(elec_tracer6, rank());
    if(err_code) 
      abort(err_code);
    // Test if tracers were moved correctly (no matches)
    err_code = test_tracer_move(electron, elec_tracer6, rank());
    if(err_code)
      abort(err_code);
  #else
    sim_log("info: testing without VPIC_ENABLE_TRACER_PARTICLES");
  #endif
  sim_log("info: "<< elec_tracer6->name <<" done");

  repeat(oldcount-electron->np) inject_particle( electron,
                              uniform( rng(0), 0, L ),   // Random location
                              uniform( rng(0), 0, L ),
                              uniform( rng(0), 0, L ),
                              normal( rng(0), 0, uthe ), // Random thermal velocity
                              normal( rng(0), 0, uthe ),
                              normal( rng(0), 0, uthe ),
                              weight,                    // Statistical weight
                              0, 0 );

  //===========================================================================
  // Move out 1237 of all particles.
  // This is a prime slightly larger than 1234.56 aka 1 percent
  //===========================================================================
  oldcount = electron->np;
  species_t * elec_tracer7 = define_tracer_species_with_n("electron_tracer_n_move", electron, TracerType::Move, 1237);
  if(!elec_tracer7) {
    sim_log("Creation of tracer7 species containing 1237 of particles failed"); abort(16);
  }

  // This time we have limited on the acceptable number of tracers
  err_code = test_tracer_move_count(electron, elec_tracer7, 1237, 1237, oldcount, rank());
  if(err_code)
    abort(err_code);

  // Moving should leave the statistical weight unchanged. Also touching all
  // particles verifies that memory allocation happend ok.
  err_code = test_tracer_move_weight(elec_tracer7, weight, rank());
  if(err_code)
    abort(err_code);

  // All particles should have unique IDs, at least if the code was compiled with GLOBAL_PARTICLE_ID
  #ifdef VPIC_ENABLE_TRACER_PARTICLES
    // Test if Tracer IDs are unique
    err_code = test_tracer_ids(elec_tracer7, rank());
    if(err_code) 
      abort(err_code);
    // Test if tracers were moved correctly (no matches)
    err_code = test_tracer_move(electron, elec_tracer7, rank());
    if(err_code)
      abort(err_code);
  #else
    sim_log("info: testing without VPIC_GLOBAL_PARTICLE_ID");
  #endif
  sim_log("info: "<< elec_tracer7->name <<" done");
  repeat(oldcount-electron->np) inject_particle( electron,
                              uniform( rng(0), 0, L ),   // Random location
                              uniform( rng(0), 0, L ),
                              uniform( rng(0), 0, L ),
                              normal( rng(0), 0, uthe ), // Random thermal velocity
                              normal( rng(0), 0, uthe ),
                              normal( rng(0), 0, uthe ),
                              weight,                    // Statistical weight
                              0, 0 );

  //===========================================================================
  // Move out particles based on a predicate
  //===========================================================================
  oldcount = electron->np;
  species_t* elec_tracer8 = define_tracer_species_by_predicate( "electron_tracer_predicate_move",
                                                                electron,
                                                                TracerType::Move,
                                                                my_predicate);
  if(!elec_tracer8) {
    sim_log("Creation of tracer4 species containing 1237 of particles failed"); abort(23);
  }

  // This time it is harder to figure out how many particles we should have.
  // About 1/8 of particles should have three positive velocity components, but
  // the actual values are randomly distributed. Instead of fixing the random
  // seed and trusting that the random numnbers don't change, I will accept
  // anything within 3 sigmas of the expected numnber, assuming a poisson
  // distribution.
  mincount = floor(Ne/8. - 3.*sqrt(Ne/8.));
  maxcount = ceil(Ne/8. + 3.*sqrt(Ne/8.));
  err_code = test_tracer_move_count(electron, elec_tracer8, mincount, maxcount, oldcount, rank());
  if(err_code)
    abort(err_code);

  // Moving should leave the statistical weight unchanged. Also touching all
  // particles verifies that memory allocation happend ok.
  err_code = test_tracer_move_weight(elec_tracer8, weight, rank());
  if(err_code)
    abort(err_code);

  // All particles should have unique IDs, at least if the code was compiled with GLOBAL_PARTICLE_ID
  #ifdef VPIC_ENABLE_TRACER_PARTICLES
    // Test if Tracer IDs are unique
    err_code = test_tracer_ids(elec_tracer8, rank());
    if(err_code) 
      abort(err_code);
    // Test if tracers were moved correctly (no matches)
    err_code = test_tracer_move(electron, elec_tracer8, rank());
    if(err_code)
      abort(err_code);
  #else
    sim_log("info: testing without VPIC_GLOBAL_PARTICLE_ID");
  #endif
  sim_log("info: "<< elec_tracer8->name <<" done");


  sim_log( "pass" );
  halt_mp();
  exit(0);
}

begin_diagnostics {
}

begin_particle_injection {
}

begin_current_injection {
}

begin_field_injection {
}

begin_particle_collisions {
}


